# Talk 4: Linux shell configuration

## Overview

- The .bashrc file
- Aliases
- The .inputrc file
- Environment variables
- The system path, $PATH
- SSH and public-private keys
- Environment modules

## Shell configuration

- The file ~/.bashrc is a shell script that Bash runs whenever it is started interactively
  + A hidden file as its name starts with '.'; display with `ls -a`
  - Often edited to include commands that users wish to execute every time they log in, without the need to explicitly type them every time
 
- New accounts on the cluster are created with a initial copy of ~/.bashrc file 
  + <span style="color:green;">Show obds cluster .bashrc</span>

- Used to configure the shell environment
  + Set aliases (shortcuts)
  + Set environment variables
  + Load environment modules (not recommended)
 
## Aliases

- Shortcut for a command or series of commands
- Reduce keystrokes and improve efficiency
- While `alias` command can be used to define shortcuts interactively in the Bash session, aliases are most commonly defined in the ~/.bashrc file, to make them available as soon as users open a new shell
- Be mindful of overriding existing command name as aliases take precedence over commands of the same name

```
$ alias la='ls -alhF'       # Informative listing of files
$ alias rm='rm -i'          # Force an interactive prompt before every removal
$ alias wd='cd </path/to/working_dir/> && pwd && ls'
```

## Environment variables

- A variable is a named place in a computer’s memory that stores a particular piece of information (e.g. number, string)
- Environment variables are defined and available in the shell’s environment
- Can be accessed by any program run in the shell
- Can be accessed using '\$' followed by variable name e.g. $USER

## Environment variables

- Can be user defined and modified
  + Once logged into the cluster, a number of environment variables are set in the Bash session

```
$ echo $HOME            # Set for each user to their own home directory
$ ls $HOME              # Use in commands
$ echo $USER            # Set for each user to their own username
$ mkdir $USER
$ printenv              # Print currently defined environment variables
$ printenv USER         # Print $USER
```

- Above are among the most commonly used variables but user can define any number of custom variable names using `export`
- Some programs might expect users to define additional environment variables

```
export TMP="$HOME"      # Not set by default, preferably define in ~/.bashrc
```

## Environment variables - System path ($PATH)

- One of the most important environment variable
- Stored as a colon-separated (:) character string that represents the list of directories that are searched – in the given order – to find executable files that are invoked by users and their scripts
- If the wanted program is not in the list of directories, it will not run
- Mpdify to add directories or remove directories (e.g. when a command is defined in multiple directories)
- Alternatively, you can provide the full path to the program you wish to run

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/l/ltamon/edirect:/home/l/ltamon/.local/bin:/home/l/ltamon/bin
```

- Whenever possible, we recommend using `module` to add and remove programs (i.e. modules) from the $PATH

## Environment modules

- Provide a central install of software available to multiple users on the same computer system 
- Dynamic modification of a user’s shell environment via modulefiles
  + Modulefiles are created by the system administrator to instruct `module` to alter or set shell environment variables such as $PATH
  + New modules can be requested from system administrators (help@imm.ox.ac.uk)[help@imm.ox.ac.uk]

```
$ module avail                              # List modules currently available
$ module <avail | search> python            # Search for specific pattern of 
                                              module names 
$ module list                               # List modules currently loaded
$ module <add | load>                       # Add or load modules 
$ module load fastqc/0.11.9 bowtie2/2.4.2   # Load multiple modules
$ module unload <module name>               # Unload 
$ module purge                              # Unload all loaded modules 
```

## Remote Connection to a Linux Server

- We log into the cluster using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure connection to a remote server
- Simply put, the protocol uses a username and password to authenticate a user on the remote system

```
$ ssh <username>@<remote / host / server>

# If applicable, connecting through a jump (bastion / proxy) host as an intermediary or gateway for extra security

$ ssh -J <jump username>@<jump host> <target username>@<target host>  
```

- To connect to the OBDS cluster, we have to use University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)

```
$ ssh -J <username>@bastion.imm.ox.ac.uk <username>@imm-obds
```
-
  + This prompts for 2 passwords, 1 for the jump host and 1 for the target host, that should be entered every time you want to connect

## Remote Connection to a Linux Server

- We can use an SSH public-private key pair (SSH key):
  + To simplify remote connection by avoiding to repeatedly enter passwords, which are likely hard to remember for security purposes)
  + To enhance security e.g. not prone to password-guessing attacks
  
## Setting up a public-private key pair

- An SSH key consists of two parts:
  + A **private** file (private key) on your local home directory 
  + A **public** file (public key) which is uploaded to the remote server you are connecting to 
- These two files enable your personal computer and the cluster to identify each other

```{r}
#| fig-align: center
#| out-height: 400px
#| out-width: 500px
## Source: CCB Doks
knitr::include_graphics("img/ssh-key-pair.png")
```

## Setting up a public-private key pair

- On your local machine, SSH key pairs and configuration files are stored in a hidden directory within your home directory called .ssh
```
$ cd ~/.ssh                         # Create if it doesn't exist
$ ssh-keygen -t ecdsa -b 521        # Generate keys
```
   + -t - To specify the type of SSH key pair
   + -b - To specify the number of bits in the key; recommended values depend on type / algorithm and current state of technology, longer keys stronger i.e. harder to crack but slows down encryption / decryption process

- You will be prompted for: 
  + A file name (if you leave blank - id_\<ssh key type> by default e.g. id_ecdsa)
  + A password or passphrase (always set a password for maximum security)

- This creates a private key (file), 'id_ecdsa' and a public key (file), 'id_ecdsa.pub' in ~/.ssh/
- Please ensure that the private key file has only read and write permissions for user and no permissions for group or other; file must be secure for the authentication to work
- <span style="color:red;"> Before generating, check now whether you have existing SSH keys in ~/.ssh. Let us know!</span>

## Adding the public key to a remote server

- The public key - generated and saved as a file on the local machine - needs to be copied to your account on the target host / cluster, so that the cluster can prove its identity to the client
```
$ ssh-copy-id -i ~/.ssh/id_ecdsa <username>@<remote>
$ ssh-copy-id -i ~/.ssh/id_ecdsa <username>@login1.molbiol.ox.ac.uk
```
- If the public key indeed does not exist on your cluster account yet, you will be prompted for your password. Type it, and press the Return key

- This adds the public key to the file ~/.ssh/authorized_keys on your account on the cluster
- A single SSH key pair can be used to authenticate and access multiple target hosts, provided that you have added the corresponding public key to the ~/.ssh/authorized_keys file on each of those target hosts for the intended user

## Configuring the SSH client 

- To easily connect with remote host/s using SSH key pair/s
- We can create a file to store ssh remote connection details for target host/s and use a shortcut (target host nickname) to access them
- These can be done by creating a file called config in your local ~/.ssh directory

```
$ cd ~/.ssh
$ nano config
```

## Configuring the SSH client

Config file to access the OBDS cluster:

:::: {.columns}

::: {.column width="60%"}

```
Host bastion
    HostName bastion.imm.ox.ac.uk
    User <username>
    IdentityFile ~/.ssh/id_ecdsa

Host obds-bastion
    HostName obds
    User <username>
    IdentityFile ~/.ssh/id_ecdsa
    ProxyJump bastion
    # for RStudio
    LocalForward localhost:8787 localhost:8787
    # for FileZilla
    LocalForward localhost:3111 localhost:22
```

:::

::: {.column width="40%"}

  + **Host** - creates a new set of parameters, can specify a nickname for the host
  + **IdentityFile** - specifies the path to the private SSH key file that you created earlier on your local machine
  + **User** - username on host (can be different between jump and target hosts)
  + **ProxyJump** - establish connection through a jump host (earlier nicknamed as bastion)
  + **LocalForward** - specify connection between a port of local machine to a port of target host, offering a particular "service" (8787 often used for RStudio, 22 often used for SSH connection); note that although there are commonly used port numbers for certain services, system admins can change this
  
:::

::::

## Configuring the SSH client

- Specifying global default parameters to be applied on all hosts:

```
Host *                            
    IdentityFile ~/.ssh/id_ecdsa  # If using an SSH key pair as a default if not 
                                    specified later on for a particular host
    
# For macOS only, add these so there's no need to enter passphrase when starting remote connection

    AddKeysToAgent yes            # Whether keys should be automatically added 
                                    to a running ssh-agent
    UseKeychain yes               # Whether passphrases are stored in the 
                                    keychain (macOS app)
```
  + '*' matches all host names, making those parameters global defaults unless overwritten in subsequent declaration
- <span style="color:green;">Look at OBDS config file template</span>

## Exercise 1 - Shell configuration

## Exercise 2 - Working with modules

<!--
## Useful links

## References

```{r}
#| results: asis
PrintBibliography(bib)
```
-->

# Bonus topics

## Advanced shell configuration 

- You may come across other Bash startup files other than ~/.bashrc e.g. ~/.profile, ~/.bash_profile

- Those other files perform a task similar to ~/.bashrc, but with subtle differences with respect to the order and the environment in which they are executed

- <span style="color:red;">We strongly discourage users from editing or creating those other files, stick with editing ~/.bashrc !</span>

## Advanced shell configuration - ~/.inputrc file

- This file allows you to customise how keystrokes are interpreted in the terminal emulator
- Like ~/.bashrc, it is a hidden file in the home directory that is applied on login
- Common shortcuts added to ~/.inputrc are:
  + "\<key combination>":\<command>
  
```
# In case of ambiguity when using tab completion, display options right away instead of asking whether to display them or not
set show-all-if-ambiguous on

# Search history of commands (forward or backward) starting with the pattern you typed (could be a command therefore)
"\e[A":history-search-backward
"\e[B":history-search-forward
```

[List of key combinations and commands from Bash Reference Manual](http://www.gnu.org/software/bash/manual/bashref.html#Command-Line-Editing)
