# Talk 4: Linux shell configuration

## Overview

- The .bashrc file
- Aliases
- The .inputrc file
- Environment variables
- The system path, $PATH
- SSH and public-private keys
- Environment modules

## Shell configuration

- The file ~/.bashrc is a shell script that Bash runs whenever it is started interactively
  + A hidden file as its name starts with '.'; display with `ls -a`
  - Often edited to include commands that users wish to execute every time they log in, without the need to explicitly type them every time
 
- New accounts on the OBDS server are created with a initial copy of ~/.bashrc file 
  + <span style="color:green;">Show obds server .bashrc</span>

- Used to configure the shell environment
  + Set aliases (shortcuts)
  + Set environment variables
  + Load environment modules (not recommended)
 
## Aliases

- Shortcut for a command or series of commands
- Reduce keystrokes and improve efficiency
- While `alias` command can be used to define shortcuts interactively in the Bash session, aliases are most commonly defined in the ~/.bashrc file, to make them available as soon as users open a new shell
- Be mindful of overriding existing command name as aliases take precedence over commands of the same name

```
$ alias la='ls -alhF'       # Informative listing of files
$ alias rm='rm -i'          # Force an interactive prompt before every removal
$ alias wd='cd </path/to/working_dir/> && pwd && ls'
```

## Environment variables

- A variable is a named place in a computer’s memory that stores a particular piece of information (e.g. number, string)
- Environment variables are defined and available in the shell’s environment
- Can be accessed by any program run in the shell
- Can be accessed using '\$' followed by variable name e.g. $USER

## Environment variables

- Can be user defined and modified
  + A number of environment variables are often set in the Bash session

```
$ echo $HOME            # Set for each user to their own home directory
$ ls $HOME              # Use in commands
$ echo $USER            # Set for each user to their own username
$ mkdir $USER
$ printenv              # Print currently defined environment variables
$ printenv USER         # Print $USER
```

- Above are among the most commonly used variables but user can define any number of custom variable names using `export`
- Some programs might expect users to define additional environment variables

```
export TMP="$HOME"      # Not set by default, preferably define in ~/.bashrc
```

## Environment variables - System path ($PATH)

- One of the most important environment variable
- Stored as a colon-separated (:) character string that represents the list of directories that are searched – in the given order – to find executable files that are invoked by users and their scripts
- If the wanted program is not in the list of directories, it will not run
- Mpdify to add directories or remove directories (e.g. when a command is defined in multiple directories)
- Alternatively, you can provide the full path to the program you wish to run

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/l/ltamon/edirect:/home/l/ltamon/.local/bin:/home/l/ltamon/bin
```

- Whenever possible, we recommend using `module` to add and remove programs (i.e. modules) from the $PATH

## Environment modules

- Provide a central install of software available to multiple users on the same computer system 
- Dynamic modification of a user’s shell environment via modulefiles
  + Modulefiles are created by the system administrator to instruct `module` to alter or set shell environment variables such as $PATH
  + New modules can be requested from system administrators (help@imm.ox.ac.uk)[help@imm.ox.ac.uk]

```
$ module avail                              # List modules currently available
$ module <avail | search> python            # Search for specific pattern of 
                                              module names 
$ module list                               # List modules currently loaded
$ module <add | load>                       # Add or load modules 
$ module load fastqc/0.11.9 bowtie2/2.4.2   # Load multiple modules
$ module unload <module name>               # Unload 
$ module purge                              # Unload all loaded modules 
```

## Remote Connection to a Linux Server

- We can log into a remote target host using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure remote connection to a target host
- Simply put, the protocol uses a username and password to authenticate a user on the remote target host

```
$ ssh <target username>@<target host>
```
  + If prompted whether to continue connecting, type 'yes' (usually appears when connecting the first time)
  + This prompts for password for user account on target host 

- If applicable, connecting through a jump (bastion / proxy) host as an intermediary or gateway for extra security

```
$ ssh -J <jump username>@<jump host> <target username>@<target host>  
```

- To connect to the OBDS server (obds), we do need to use University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)

```
$ ssh -J <username>@bastion.imm.ox.ac.uk <username>@obds
```

-
  + This prompts for 2 passwords, 1 for the jump host and 1 for the target host, that should be entered every time you want to connect

- <span style="color:red;">Does everyone know their username?</span>
 
## Remote Connection to a Linux Server

- Typing the `ssh` command and all its options works on the command line 
  + but could be tedious especially when using a jump host as in our case and needing to repeatedly connect
- To minimise typing when connecting to a remote target host, we can
  + Use an SSH public-private key pair (SSH key) **(1)** to avoid repeatedly entering passwords, which are likely hard to remember for security purposes, and **(2)** to enhance security e.g. not prone to password-guessing attacks
  + Use an ssh config file to store ssh connection details to multiple target hosts and accessing them using host shortcuts or nicknames, instead of typing long `ssh` commands
  
## Setting up a public-private key pair

- An SSH key consists of two parts:
  + A **private** file (private key) on your local home directory 
  + A **public** file (public key), which is copied to the remote host you are connecting to 
- These two files enable your personal computer and the target host to identify each other

```{r}
#| fig-align: center
#| out-height: 400px
#| out-width: 500px
## Source: CCB Doks
knitr::include_graphics("img/ssh-key-pair.png")
```

## Setting up a public-private key pair

- On your local machine, SSH key pairs and configuration files are stored in a hidden directory within your home directory called .ssh
```
$ cd ~/.ssh                         # Create if it doesn't exist
$ ssh-keygen -t ecdsa -b 521        # Generate private and public keys / files
```
   + -t - To specify the type of SSH key pair
   + -b - To specify the number of bits in the key; recommended values depend on type / algorithm and current state of technology, longer keys stronger i.e. harder to crack but slows down encryption / decryption process

## Setting up a public-private key pair

- You will be prompted for: 
  + A file name (if you leave blank - id_\<ssh key type> by default e.g. id_ecdsa)
  + A password or passphrase (ideally, always set a password for maximum security, but for Git Bash users please leave this blank for now because unlike in macOS, the passphrase cannot be stored by the SSH agent so you would need to input it everytime)

- This creates a private key (file), 'id_ecdsa' and a public key (file), 'id_ecdsa.pub' in ~/.ssh/
- Please ensure that the private key file has only read and write permissions for user and no permissions for group or other; file must be secure for the authentication to work
- <span style="color:red;">Before generating, check whether you have existing SSH keys in ~/.ssh on your local machine. Let us know!</span>

## Adding the public key to a remote server

- The public key, generated and saved as a file on the local machine, needs to be copied to your account on the target host, so that the target host can prove its identity to the client

```
$ ssh-copy-id -i ~/.ssh/id_ecdsa <target username>@<target host>
```
  + If the public key indeed does not exist on the target host yet, you will be prompted for your password; Type it, and press the Return key
  + This adds the public key to the file ~/.ssh/authorized_keys on the target host

## Adding the public key to a remote server

- If connecting through a jump host as in our case, the public key has to be copied to the jump host and then copied to the target host

```
$ ssh-copy-id -i ~/.ssh/id_ecdsa <username>@bastion.imm.ox.ac.uk

# If successful, you should be able to connect to the jump host without your account password 
# and then now, we can copy the same public key to target host

$ ssh-copy-id -i ~/.ssh/id_ecdsa -o ProxyJump=<username>@bastion.imm.ox.ac.uk <username>@obds
```

- A single SSH key pair can be used to authenticate and access multiple hosts, provided that you have added the corresponding public key to the ~/.ssh/authorized_keys file on each of those hosts for the intended user
  + We used the same SSH key pair for the jump host and target host
  
- At this point, you should be able to log in to the OBDS server without entering passwords for your accounts in the jump host and OBDS server 

## Configuring the SSH client 

- We have avoided entering multiple passwords but the command we have to use to connect to the OBDS server is still pretty long! 
  + and will be longer if we need more options to configure the connection

```
$ ssh -J <username>@bastion.imm.ox.ac.uk <username>@obds
```

- We can create an SSH config file to 
  + Shorten `ssh` command we type every time we connect 
  + Easily add other `ssh` options to configure connections
  + Specify SSH key pairs to be used for each or multiple hosts
 
- Create a file called config in your local ~/.ssh directory

```
$ cd ~/.ssh
$ nano config
```

## Configuring the SSH client

Config file to access the OBDS server:

:::: {.columns}

::: {.column width="60%"}

```
Host bastion
    HostName bastion.imm.ox.ac.uk
    User <username>
    IdentityFile ~/.ssh/id_ecdsa

Host obds-bastion
    HostName obds
    User <username>
    IdentityFile ~/.ssh/id_ecdsa
    ProxyJump bastion
    # for RStudio
    LocalForward localhost:8787 localhost:8787
    # for FileZilla
    LocalForward localhost:3111 localhost:22
```

:::

::: {.column width="40%"}

  + **Host** - creates a new set of parameters, can specify a nickname for the host
  + **IdentityFile** - specifies the path to the private SSH key file that you created earlier on your local machine
  + **User** - username on host (can be different between jump and target hosts)
  + **ProxyJump** - establish connection through a jump host (earlier nicknamed as bastion)
  + **LocalForward** - specify connection between a port of local machine to a port of target host, offering a particular "service" (8787 often used for RStudio, 22 often used for SSH connection)
  
:::

::::

## Configuring the SSH client

- Specifying global default parameters to be applied on all hosts:

```
Host *                            
    IdentityFile ~/.ssh/id_ecdsa  # If using an SSH key pair as a default if not 
                                    specified later on for a particular host
    
# For macOS only, add these so there's no need to enter passphrase when starting remote connection

    AddKeysToAgent yes            # Whether keys should be automatically added 
                                    to a running ssh-agent
    UseKeychain yes               # Whether passphrases are stored in the 
                                    keychain (macOS app)
```
  + '*' matches all host names, making those parameters global defaults unless overwritten in subsequent declaration
- <span style="color:green;">Look at OBDS config file template</span>

## Configuring the SSH client

- Once you have the config file, the original `ssh` command to connect to the OBDS server *via* the bastion host can be simplied 

```
# From
ssh -J <username>@bastion.imm.ox.ac.uk <username>@obds

# To
ssh obds-bastion
```

# Talk 2 Exercise 1 - Shell configuration

# Talk 2 Exercise 2 - Working with modules

<!--
## Useful links
-->

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

# Bonus topics

## Advanced shell configuration 

- You may come across other Bash startup files other than ~/.bashrc e.g. ~/.profile, ~/.bash_profile

- Those other files perform a task similar to ~/.bashrc, but with subtle differences with respect to the order and the environment in which they are executed

- <span style="color:red;">We strongly discourage users from editing or creating those other files, stick with editing ~/.bashrc !</span>

## Advanced shell configuration - ~/.inputrc file

- This file allows you to customise how keystrokes are interpreted in the terminal emulator
- Like ~/.bashrc, it is a hidden file in the home directory that is applied on login
- Common shortcuts added to ~/.inputrc are:
  + "\<key combination>":\<command>
  
```
# In case of ambiguity when using tab completion, display options right away instead of asking whether to display them or not
set show-all-if-ambiguous on

# Search history of commands (forward or backward) starting with the pattern you typed (could be a command therefore)
"\e[A":history-search-backward
"\e[B":history-search-forward
```

[List of key combinations and commands from Bash Reference Manual](http://www.gnu.org/software/bash/manual/bashref.html#Command-Line-Editing)

<span style="color:green;">DEMO</span>

