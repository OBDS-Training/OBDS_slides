# Talk 2: Linux shell configuration

## Overview

- The .bashrc file
- Aliases
- Environment variables e.g. the system path, $PATH
- Environment modules
- SSH and public-private keys for remote connection to a Linux server

## Shell configuration

- The file ~/.bashrc is a shell script that Bash runs whenever it is started interactively
  + A hidden file as its name starts with '.'; display with `ls -a`
  - Often edited to include commands that users wish to execute every time they log in, without the need to explicitly type them every time
 
- Typically, new accounts on Linux servers are created with an initial copy of ~/.bashrc file 

- Used to configure the shell environment
  + Set aliases (shortcuts)
  + Set environment variables
  + Load environment modules (not recommended)
 
## Aliases

- Shortcut for a command or series of commands
- Reduce keystrokes and improve efficiency
- While `alias` command can be used to define shortcuts interactively in the Bash session, aliases are most commonly defined in the ~/.bashrc file, to make them available as soon as users open a new shell
- Be mindful of overriding existing command name as aliases take precedence over commands of the same name

```
$ alias la='ls -alhF'       # Informative listing of files
$ alias rm='rm -i'          # Force an interactive prompt before every removal

$ alias wd='cd </path/to/working_dir/> && pwd && ls
```

## Environment variables

- A variable is a named place in a computer’s memory that stores a particular piece of information (e.g. number, string)
- Environment variables are defined and available in the shell’s environment
- Can be accessed by any program run in the shell
- Can be accessed using '\$' followed by variable name e.g. $USER

## Environment variables

- Can be user defined and modified
  + A number of environment variables are often set in the Bash session

```
$ echo $HOME            # Set for each user to their own home directory
$ ls $HOME              # Use in commands
$ echo $USER            # Set for each user to their own username
$ mkdir $USER
$ printenv              # Print currently defined environment variables
$ printenv USER         # Print $USER
```

- Above are among the most commonly used variables but user can define any number of custom variable names using `export`
- Some programs might expect users to define additional environment variables

```
export TMP="$HOME"      # Not set by default, preferably define in ~/.bashrc
```

## Environment variables - System path ($PATH)

- One of the most important environment variable
- Stored as a colon-separated (:) character string that represents the list of directories that are searched – in the given order – to find executable files that are invoked by users and their scripts

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/l/ltamon/edirect:/home/l/ltamon/.local/bin:/home/l/ltamon/bin
```

- If the wanted program is not in the list of directories, it will not run
- Modify to add directories or remove directories (e.g. when a command is defined in multiple directories)
- Alternatively, you can provide the full path to the program you wish to run
- Whenever possible, we recommend using `module` to add and remove programs (i.e. modules) from the $PATH

## Environment modules

- Provide a central install of software available to multiple users on the same computer system 
- Dynamic modification of a user’s shell environment via modulefiles
  + Modulefiles are created by the system administrator to instruct `module` how software will be loaded or configured e.g. adding path of software to environment variable, $PATH
  + New modules can be requested from system administrators 

```
$ module avail                              # List modules currently available
$ module <avail | search> python            # Search for specific pattern of 
                                              module names 
$ module list                               # List modules currently loaded
$ module <add | load>                       # Add or load modules 
$ module load fastqc/0.11.9 bowtie2/2.4.2   # Load multiple modules
$ module unload <module name>               # Unload 
$ module purge                              # Unload all loaded modules 
```

<!--

## Remote connection to a Linux server

- We can log into a remote target host using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure remote connection to a target host
- Simply put, the protocol uses a username and password to authenticate a user on the target host
  ```
  $ ssh <target username>@<target host>
  ```
  + If prompted for authenticity of host and whether to continue connecting, type 'yes' (usually appears when connecting the first time)
  + This then prompts for the password for the user account on target host 

## Remote connection to a Linux server *via* a jump host

- Sometimes, the connection has to be through a jump (bastion / proxy) host as an intermediary or gateway for extra security

```
$ ssh -J <jump username>@<jump host> <target username>@<target host> 

# OR

$ ssh -o ProxyJump=<jump username>@<jump host> <target username>@<target host>
```

<br>

- To connect to the OBDS server (obds), we do need to use University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)

  ```
  $ ssh -o ProxyJump=<username>@bastion.imm.ox.ac.uk <target username>@obds
  ```
  + If prompted for authenticity of host and whether to continue connecting, type 'yes'
  + **This then prompts for 2 passwords**, 1 for the jump host and 1 for the target host, that should be entered every time you want to connect
  + <span style="color:red;">For people within the University, the username is your SSO for both hosts</span>

-->

## Remote connection to a Linux server

- Typing the `ssh` command and all its options works on the command line 
  + but could be tedious especially when using a jump host as in our case and needing to repeatedly connect
- To minimise typing when connecting to a remote target host, we can:
  + Use an **SSH public-private key pair (SSH key)** **(1)** to avoid repeatedly entering passwords, which are likely hard to remember for security purposes, and **(2)** to enhance security e.g. not prone to password-guessing attacks
  + Use an **SSH config file** to store SSH connection details to multiple target hosts and accessing them using host shortcuts or nicknames, instead of typing long `ssh` commands
  + <span style="color:red;">Note that these two are independent, you can do either or both! We will do both of course!</span>
  
## Setting up a public-private key pair

- An SSH key pair consists of two parts:
  + A **private** key (a file) on your local home directory 
  + A **public** key (a file), which is copied to the remote host you are connecting to 
- These two files enable your personal computer and the target host to identify each other

```{r}
#| fig-align: center
#| out-height: 450px
#| out-width: 550px
## Source: CCB Doks
knitr::include_graphics("img/ssh-key-pair.png")
```

## Setting up a public-private key pair

- On your local machine, SSH key pairs and configuration files are stored in a hidden directory within your home directory called .ssh
  ```
  $ cd ~/.ssh                         # Create if it doesn't exist
  ```
  + <span style="color:red;">Before generating, check whether you have existing SSH keys in ~/.ssh on your local machine. Let us know!</span>

- Generate private and public keys / files
  ```
  $ ssh-keygen -t ecdsa -b 521        
  ```
  + -t - To specify the type of SSH key pair
  + -b - To specify the number of bits in the key -- recommended values depend on type / algorithm and current state of technology -- longer keys stronger i.e. harder to crack but slows down encryption / decryption process

## Setting up a public-private key pair

- You will be prompted for: 
  + A file name for both keys (if you leave blank by pressing Return key -- id_\<ssh key type> by default e.g. id_ecdsa)
  + A passphrase 
    - Ideally, always set a passphrase for maximum security, but for now let's just leave the passphrase blank (just press Return key) 

- The command creates files in **~/.ssh/**:
  + A private key (file), **'id_ecdsa'** 
  + A public key (file), **'id_ecdsa.pub'** 
- Please ensure that the private key has only read and write permissions for user and no permissions for group or other 

## Adding the public key to a remote server

- The public key, generated and saved as a file on the local machine, needs to be copied to the target host

  ```
  $ ssh-copy-id -i ~/.ssh/id_ecdsa <target username>@<target host>
  ```
  + This will prompt for password of your account on target host
  + If the public key indeed does not exist on the target host yet, you will be prompted for your password -- Type it, and press the Return key
  + This adds the public key to the file ~/.ssh/authorized_keys on the target host

- Once the public key has been copied you can log into the host using the SSH key pair for authentication rather than your passwords
  + But this will still prompt for the SSH key passphrase if you have it

## Adding the private key to SSH agent

- To avoid typing your SSH key passphrase every time you use the key, you can add your key to an SSH authentication agent
  + <span style="color:red;">Skip this step if you did not provide an SSH key passphrase</span>

  ```
  $ eval `ssh-agent -s`           # Activate SSH agent
  $ ssh-add ~/.ssh/id_ecdsa       # Add private key to agent
  ```
  + <span style="color:red;">Note that the agent activation and key addition have to be done every time you start a 'session'</span>
    - Say you started a new terminal window, you have to run the two commands again! We can get rid of these steps using the SSH config file (TBD)!
 
## Adding the public key to both jump and target hosts

- If connecting through a jump host as in our case, the public key has to be copied to the jump host and then copied to the target host

```
$ ssh-copy-id -i ~/.ssh/id_ecdsa <username>@bastion.imm.ox.ac.uk

# If successful, you should be able to connect to the jump host without your account password 

# and then now, we can copy the same public key to target host

$ ssh-copy-id -i ~/.ssh/id_ecdsa -o ProxyJump=<username>@bastion.imm.ox.ac.uk <username>@obds
```

<br>

- A single SSH key pair can be used to authenticate and access multiple hosts, provided that you have added the corresponding public key to the ~/.ssh/authorized_keys file on each of those hosts for the intended user
  + We used the same SSH key pair for the jump host and target host
  
- <span style="color:green;">At this point, you should be able to log into the OBDS server *via* bastion host without entering passwords for your accounts in both hosts</span>

## Configuring the SSH client 

- With the SSH key pair, we added extra security as well as avoided entering multiple passwords but the command we have to use to connect to the OBDS server is still pretty long! 
  + and will be longer if we need more options to configure the connection

```
$ ssh -o ProxyJump=<username>@bastion.imm.ox.ac.uk <username>@obds
```

- We can create an SSH config file to 
  + Shorten `ssh` command we type every time we connect 
  + Easily add other `ssh` options to configure connections
  + Specify SSH key pairs to be used for each or multiple hosts
 
- Create a file called config in your local ~/.ssh directory

```
$ cd ~/.ssh
$ nano config
```

## Configuring the SSH client

Config file to access the OBDS server:

:::: {.columns}

::: {.column width="60%"}

```
Host bastion
    HostName bastion.imm.ox.ac.uk
    User <username>
    IdentityFile ~/.ssh/id_ecdsa

Host obds-bastion
    HostName obds
    User <username>
    IdentityFile ~/.ssh/id_ecdsa
    ProxyJump bastion
    # for RStudio
    LocalForward localhost:8787 localhost:8787
    # for FileZilla
    LocalForward localhost:3111 localhost:22
```

:::

::: {.column width="40%"}

  + **Host** - creates a new set of parameters, can specify a nickname for the host
  + **IdentityFile** - specifies the path to the private SSH key file that you created earlier on your local machine
  + **User** - username on host (can be different between jump and target hosts)
  + **ProxyJump** - establish connection through a jump host (earlier nicknamed as bastion)
  + **LocalForward** - specify connection between a port of local machine to a port of target host, offering a particular "service" (8787 often used for RStudio, 22 often used for SSH connection)
  
:::

::::

## Configuring the SSH client

- Specifying global default parameters to be applied on all hosts:

```
Host *                            
    IdentityFile ~/.ssh/id_ecdsa  # If using an SSH key pair as a default if not 
                                    specified later on for a particular host
    
# For macOS only, add these so there's no need to enter passphrase when starting remote connection

    AddKeysToAgent yes            # Whether keys should be automatically added 
                                    to a running ssh-agent
    UseKeychain yes               # Whether passphrases are stored in the 
                                    keychain (macOS app)
```
  + '*' matches all host names, making those parameters global defaults unless overwritten in subsequent declaration

## Remote connection to the OBDS server

- OBDS config file template:

```
Host *
    IdentityFile ~/.ssh/id_ecdsa
    AddKeysToAgent yes
#    UseKeychain no

Host bastion
    HostName bastion.imm.ox.ac.uk
    User exet4759
#    IdentityFile ~/.ssh/id_ecdsa

Host obds-bastion
    HostName obds
    User exet4759
#    IdentityFile ~/.ssh/id_ecdsa
    ProxyJump bastion
    # for RStudio
    LocalForward localhost:8787 localhost:8787
    # for FileZilla
    LocalForward localhost:3111 localhost:22
```

- Once you have the config file, the original `ssh` command to connect to the OBDS server *via* the bastion host can be simplified: 

```
# From
ssh -o ProxyJump=<username>@bastion.imm.ox.ac.uk <username>@obds

# To
ssh obds-bastion
```

## Transferring files across systems on the command line using `scp`

- Transferring files *via* bastion host from OBDS server to local machine:
```
$ scp -o ProxyJump=<username>@bastion.imm.ox.ac.uk <username>@obds:<source path> <destination path>
```

- With the SSH config, we can simplify to:
```
$ scp obds-bastion:<source path> <destination path>
```

- `scp` vs. `rsync`
   + `scp` - Straightforward copying of files using SSH
   + `rsync` - Synchronises files and directories between a source and a destination 

- <`scp` | `rsync`> \<options> \<source> \<destination>

# Talk 2 Exercise 1 (Shell configuration) and 2 (Working with modules)

@sec-Talk2Exercise1

<!--
## Useful links
-->

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

# Bonus topics

## Advanced shell configuration 

- You may come across other Bash startup files other than ~/.bashrc e.g. ~/.profile, ~/.bash_profile

- Those other files perform a task similar to ~/.bashrc, but with subtle differences with respect to the order and the environment in which they are executed

- <span style="color:red;">We strongly discourage users from editing or creating those other files, stick with editing ~/.bashrc!</span>

## Advanced shell configuration - ~/.inputrc file

- This file allows you to customise how keystrokes are interpreted in the terminal emulator
- Like ~/.bashrc, it is a hidden file in the home directory that is applied on login
- Common shortcuts added to ~/.inputrc are:
  + In case of ambiguity when using tab completion, display options right away instead of asking whether to display them or not
  ```
  set show-all-if-ambiguous on
  ```
  
  + Search history of commands (forward or backward) starting with the pattern you typed (could be a command therefore)
  + "\<key combination>":\<command>
  
  ```
  "\e[A":history-search-backward
  "\e[B":history-search-forward
  ```
  
  + [List of key combinations and commands from Bash Reference Manual](http://www.gnu.org/software/bash/manual/bashref.html#Command-Line-Editing)

<span style="color:green;">DEMO on OBDS server</span>

