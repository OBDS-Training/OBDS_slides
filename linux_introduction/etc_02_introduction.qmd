# Talk 2: Introduction to the Linux command line

## Overview

<!--
- Linux is a type of computer operating system (OS), like Windows or MacOS, that is part of the Unix family of OS
- Linux is frequently used in high-performance computing and applications e.g. in Computational Biology
-->

:::: {.columns}

::: {.column width="50%"}
- Outline:
  + Introduction to the Linux shell 
  + Linux commands 
  + Navigating the Linux file system
  + Viewing and editing files
  + File properties and permissions
  + Copying, moving and renaming files and directories
  + Hard and symbolic links
  + Deleting files and directories
:::

::: {.column width="50%"}
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/UNIX-Logo-500x281.jpg")
```
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/linux-logo/
knitr::include_graphics("img/Symbol-Linux.jpg")
```
:::

::::

## Linux shell - Terminology alert!

<!-- 
Nice explanation in https://www.freecodecamp.org/news/command-line-for-beginners/ and
https://www.freecodecamp.org/news/the-linux-commands-handbook/#introductiontolinuxandshells
-->

- Linux is an Operating System (OS), like MS Windows and macOS, but open source (source code is freely available!) 
- All OS have a  **shell** i.e. a command-line interpreter
  + It processes the commands, giving them to the OS and outputs the results
- There are different shells differing in syntax and characteristics

## Linux shell - Terminology alert!

- Most widely used shell for Linux is **BASH** (Bourne Again Shell)
  + Often used in the CCB cluster but others are available for use
- The **terminal** or **command-line interface**, where user inputs commands, is used to interact with the shell
  + The command-line prompt (input field) is indicated by a certain character depending on the OS ($ for Linux)

:::: {.columns}

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 200px
#| out-width: 400px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_bash.png")
```
:::

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 200px
#| out-width: 400px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_emulator.png")
```
:::

::::

## Linux commands

- Basic part/s (Text in \<arrows> indicates a variable which should be replaced)
  + \<command>      
  + \<command> \<argument> 
  + \<command> \<options> \<argument> 
  
- Types
  + **Shell builtin** - Built into the shell itself
  + **Executable program** - Any external software in the system path (where OS looks for executable programs)
  + **Alias** - User-defined command built using other commands (TBD)
  
```
$ type cd                        # ‘type’ shows the type of command
cd is a shell builtin

$ type head
head is /usr/bin/head
      
$ which head                     # ‘which’ returns the path of the file to be executed
/usr/bin/head
```

## Linux command options

- Commands have options that modify their functions
  + \<command> \<options> \<argument>
  + Short options start with '-', long options start with '\-\-' (TBD)

```
$ which head
/usr/bin/head

$ which -a head                  # '-a' to print all matching paths of each argument
/usr/bin/head
/bin/head
```

## Some useful Bash keyboard shortcuts

- **Tab** - autocomplete (will prompt if ambiguous)
  + Predict rest of word (e.g. command or file path/name) based on first few typed characters
  
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/tab_autocompletion.png")
```

- **Up and down arrows** - Access history of commands
- **Control + c** - Abort current command
- **Control + a** - Go to start of line
- **Control + e** - Go to end of line

**DEMO**

## Getting help with linux commands

- Different ways
  + `man` shows manual pages of the command
  + Press 'q' to exit

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 800px
## Source: screenshot from jade
knitr::include_graphics("img/man_head.png")
```

## Getting help with linux commands

- Different ways
   + `--help`
   + Different format with `man`

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 600px
## Source: screenshot from jade
knitr::include_graphics("img/help_head.png")
```

## Getting help with linux commands

- Different ways
  + Google search!
  + Use in combination with command-line ways for more information that is accurate and up to date

```{r}
#| fig-align: center
#| out-height: 350px
#| out-width: 600px
## Source: Google search! :>
knitr::include_graphics("img/google_head.png")
```

## Linux file system tree

- In Linux, everything is a file organised in a tree structure
- A directory is just a file containing names of other files
- All directories branch off from the **root** directory
- **home** is your personal (user) directory

```{r}
#| fig-align: center
#| out-height: 350px
#| out-width: 600px
## Source: https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained
knitr::include_graphics("img/linux_file_tree.png")
```

## Commands to navigate the file structure

- Basic commands

```
$ type cd                        # ‘type’ shows the type of command
$ pwd                            # Print working directory
/home/<user>                     # When you log into the CCB cluster, the working directory is                                      # initially set to the user’s home directory.
$ ls                 
Desktop  Documents  Downloads...

$ cd Desktop                     # Change directory

$ pwd
/home/<user>/Desktop
```

## Working with Paths 

Path is the location to a file

:::: {.columns}

::: {.column width="50%"}

- Absolute paths
  + Absolute paths always starts with the root directory ('/')
  + Given by `realpath`
  
    ```
    $ realpath foo
    /home/mthomas/class_stuff/foo
    ```
:::

::: {.column width="50%"}

- Relative paths 
  + Relative paths are relative to the current working directory
  + Does not start with '/'

    ```
    $ pwd 
    /home/mthomas/class_stuff/foo
    
    $ cd ../bar                      # Go to bar
    $ cd ../../bin                   # Go to bin
    ```
:::

::::


:::: {.columns}

::: {.column width="40%"}

- Path shortcuts
  + .  (full stop)     current directory 
  + .. (2 full stops)  parent directory
  + ~  (tilde)         home directory
  + /  (forward slash) root directory
  
:::

::: {.column width="60%"}

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 600px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/sample_working_tree.png")
```

:::

::::

## Working with Paths

- Tips
  + Prompt tells you your current working directory
  + Always use tab autocompletion to avoid typos 
    - Command-line interpreters may figure out whether you need a command or file path
  + `ls` output can be set to be coloured to indicate the type of each file 
    - <span style="color:indigo;">Directory</span>
    - File - black 
    - <span style="color:cyan;">Symbolic link</span> (TBD) 
    - <span style="color:#b84e38;">Compressed file</span>
    
**DEMO** 

## Viewing text files on the command line

- Useful commands

```
$ cd ../bar                      
$ cat <filename>                 # Print the entire file contents to the terminal
                                 # If taking a while, interrupt with Control + c
$ head -n 20 <filename>          # Print the first n lines to the terminal (default=10)
$ tail -n 20 <filename>          # Print the last n lines to the terminal (default=10)
$ wc <filename>                  # Count the number of bytes (-m), characters (-m), lines (-l) etc.
```

- Interactively scroll through files

```
$ more <filename>                # Scroll through a file unidirectionally from top to bottom
$ less <filename>                # Like more but allows backward movement, "less is more"
                                 # Up and down arrow keys to scroll one line up or down
                                 # Left and right arrow keys to scroll one screen worth left or right across contents
                                 # Similar to more, use space bar to scroll down one screen worth of contents
                                 # Unlike more, reaching end will not terminate interactive viewer
                                 # Similar to more, exit anytime with 'q'
```

## Make a remote connection to a Linux server

- We can do a remote command line login to a Linux system using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure connection to a remote server
- The protocol uses a username and password to authenticate a user on the remote system
- We can log into the cluster using `ssh`
- From your local Linux shell (Terminal / Git Bash):
```
$ ssh <username>@<remote>
$ ssh <username>@login1.molbiol.ox.ac.uk 
$ ssh <username>@login2.molbiol.ox.ac.uk 
```

## Make a Remote Connection to a Linux Server

- For the very first connection, you may be prompted to verify the authenticity of the host
  + Type 'yes' and press the Return key to continue connecting

- When prompted for your password, type it and press the Return key

- To logout, use any of the following:
  + Type 'exit' and press the Return key
  + Type 'logout' and press the Return key
  + Press Control + d
  
## Exercise 1 – Files and directories part 1

1. Log into the cluster using `ssh`.
2. Establish your current location in the file system.
3. List all the files and directories in your current directory (including hidden files).
4. Change into your course working directory, **/project/obds/\<username>/**.
5. Change into the course shared directory, **/project/obds/shared/resources/**.
6. Change into the directory **1_linux/1_linux_intro/**.
7. View the file **manpage.txt** on the command line (try `cat`, `wc`, `head` and `tail`, `more` and `less`).
9. What type of command is `history`? What is it for?

## Changing how you view files using ``ls`` options

:::: {.columns}

::: {.column width="50%"}

- Short options can be bundled

```
$ ls -l -t -a -h -F                      
$ ls -ltahF                      # Short options can be bundled  
```
  + -l = Long format, displaying detailed information (e.g. permissions, size, timestamp of latest update)
  + -t = Sort files by modification time (newest first)
  + -a = Show hidden files
  + -h = Human readable numbers
  + -F = Append an indicator to the end of each listed name (e.g. / for a directory)

```
$ ls --help
$ man ls
```

:::

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_options.png")
```

:::

::::

## File properties and permissions

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output_labeled.png")
```

- `ls -l` used to display file permissions

## File permissions - Owner

- Linux is a multi-user operating system
- Access to read, write and execute each file / directory is controlled
- Each file is owned by exactly one user

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output.png")
```

## File permissions – group & other

- A group is a collection of one or more users
- Each user can be a member of multiple groups 
- A file can be owned by exactly one group
- To see the groups that your user currently belongs to, type:
```
$ groups
```
- The last category that you can assign permissions for is the **‘other’** category
  + Any user that is not the file owner and 
  + is not a member of the group that owns the file
- This allows you to set permissions that will apply to anyone outside of the two control groups
  + Any user that is not the file owner and
  + is not a member of the group that owns the file

## Types of permissions

- Each permissions category (owner, group and other) can be assigned permissions that restrict their ability to read, write, or execute a file
- For a regular file
  + **Read** permissions are required to read the contents of a file (**open**)
  + **Write** permissions are necessary to **modify** it
  + **Execute** permissions are needed to **run the file** as a program
- For directories
  + **Read** permissions are necessary to **list** the contents of a directory
  + **Write** permissions are required to **modify** the contents of a directory
  + **Execute** permissions allow a user to **navigate** into the directory
- Linux represents these types of permissions using alphabetic or octal notations

## Alphabetic notation

- More verbose and easier to read and write than the octal notation

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 300px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 18)
knitr::include_graphics("img/alphabetic_notation.png")
```

## Changing file permissions using alphabetic notation

- Most commonly, changes in file permissions are made to
  + Make script files executable
  + Make valuable files (e.g. raw sequencing data) read-only, to avoid accidentally deleting them
  
- Do not change file permissions to give other users access to your own files and directories
- Instead, contact the system administrators to request project directories that are set up with shared access for collaborators
  
## Changing file permissions using alphabetic notation

- We can change file permissions with ``chmod`` using alphabetic notation
- `chmod` <permissions> <file or directory>
  + u for user, g for group, o for other
  + - to deny access, + to give access
  + r for read, w for write, x for execute
  + , for separating multiple sets of changes 

```
$ chmod u+x,g-w,o-r file1.txt
```
  + u+x to add execute permission for the user who owns the file 
  + g-w to remove write permission for the user group assigned to the file 
  + o-r to remove read permission for every other user 

```
$ chmod go-rwx file1.txt         # Can be bundled together when applying same permission to groups        
$ ls -l file1.txt
-rwx------ 1 dsims root 2981 Apr 26  2020 file1.txt
```
## Viewing and editing files on the command line using interactive text editors

- No graphical interface or mouse required
- Tools
  + Vim and Emacs 
    - Been around for 40 years, widely used, large number of add-ons
    - Can be heavily customised (e.g. keyword highlighting, code auto-completion)
    - But users need to learn a set of keyboard shortcuts
  + Nano - more basic and so recommended for beginners
- To edit a file, type either one of these
```
$ vim <filename>  
$ emacs <filename>
$ nano <filename>
```

## Creating files and directories

```
$ touch <filename>              # Create new empty file (can create several at a time)
                                # If file exists, will update timestamp to current time
                            
$ nano <filename>               # Open new empty file in nano editor
                                # If file exists, will open file for editing
                                
$ mkdir <dir1>                  # Create new directory
$ mkdir <dir1> <dir2>           # Create multiple new directories
```

## Working using nano

- The arrow keys can be used to move the cursor through the file
- Common keyboard shortcuts are displayed at the bottom of the editor
  + The ^ symbol represents the Control key
  + For instance, ^X indicates that pressing the Control + x will exit the interactive text editor

- To save edits made to a file:
  + Press the Control and X keys simultaneously to initiate the exit from the editor
  + When prompted whether to ‘Save modified buffer’, press Y to confirm (N to discard changes)
  + When prompted for the ‘File Name to Write’, immediately press the Return key to use the current
  file name (or edit file name as needed)

## Copying, moving and renaming files

```
$ cp file1 file2                # Copy file to new file
$ cp -n file1 file2             # Do not overwrite if file2 exists
$ cp file1 dir1/                # Copy file to new directory
$ cp -r dir1/ dir2/             # cp needs -r to recursively copy contents of directories (empty or not) 
                                  to a new directory (does not need to exist beforehand)
                                # If dir2/ already exists, the copy will be created inside dir2/

$ mv file1 file1.csv            # Rename file
$ mv file1 dir1/file.csv        # Move file to new directory and rename (-n to not overwrite)
$ mv dir1/ dir2/                # Rename directory, no need for -r
                                # But if dir2/ exists, dir1/ will be moved to dir2/ 
```

## Deleting files & directories 

```
$ rm file1                              # Remove file
$ rm file1.txt file1.csv file2* *.csv   # Remove multiple files, use wildcard (*)
                                        # Also delete all files whose names start with file2 and all files that end with .csv
$ rm -r dir1                    # Remove directory and contents     
$ rm -rv dir1                   # Verbosely display list of files to be removed
$ rmdir dir1                    # Remove empty directory, will raise an error if directory is not empty
$ rmdir dir1 dir2               # Will only remove empty directories
```

- **<span style="color:red;">!!! There is no undo or recycle bin so be careful when using `rm` !!!</span>**
  + Particularly with -r (recursive) or * (wildcard)
  + **Good news**, you can only remove files you have permission to delete
  

## Using wildcards (*)

- Wildcards are special characters that match one or more characters in filenames
- Therefore they are used to specify groups of file names matching a pattern
- Main wildcards
  + \* - Matches any sequence of characters 
  + ? - Matches any single character

- Example globs (term used in Linux):
```
$ ls *.jpg                      # Lists all files with the .jpg extension
$ ls sample1*                   # Lists all files which start with sample1
$ ls *temp*                     # Lists all files with temp anywhere in the file name
$ file?.*                       # Multiple wildcards can be used in the same pattern
```

## Hard & symbolic links to files and directories

- A hard link is an additional name for an existing file
- A symbolic link (soft link or abbreviated symlinks) is a file that contains a text pointer to a target file or directory
- Symbolic links overcome disadvantages of hard links:
  + Deleting all the hard links to a file will effectively delete the file itself
  + Hard links cannot span physical devices (disks and the CCB cluster is composed of many nodes and disks)
  + Hard links cannot reference directories but only files
- The advantage of hard links is that the original and linked files remain linked even when either or both files are moved
- Symbolic links become unusable if target file is moved or deleted unless they are updated

## Hard & symbolic links to files and directories

- Symbolic links can point to target files using absolute or relative paths (relative to location of symlink)
  + With absolute paths, symlink will continue to point to the same location even if the symlink itself is moved
  + With relative paths, symlink will point to a new location if the symlink itself is moved (relative to new location of symlink)

```
$ ln file1 link1.csv            # Create hard link
$ ln file1 link1.csv            # Create symbolic link
$ ln dir1 link1                 # Create symbolic link
```

- **Do not create hard links on the CCB cluster. If you think you need a hard link, contact system administrators first to enquire**

## File types and extensions
 
- Files can be:
  + Plain text - contain only characters of readable materials that can be displayed by most text editors
  + Binary - not plain text (e.g. compiled programs, images)
- Many files use a standardised internal organisation called a file format
  + Having a standard allows for consistency
  + Enables software to easily extract defined information
- Many programs make use of file extensions in their input and output file names:
  + To parse the contents of input files according to their format 
  + To indicate the format used to write the contents of their output files

- Good habit to use an appropriate file extension even just using the generic '.txt' to indicate that the file contains plain text information

## File types and extensions

- There are several biological file formats
  + .fasta - biological sequence information
  + .fastq (.fq) - sequence information with quality scores
  + .sam, .bam - alignments of sequences to a reference genome
  + .gtf, .bed - genomic coordinates of sequence features (e.g. exons, peaks)
- In bioinformatics, binary file formats are commonly used to store compressed versions of equivalent plain text files (e.g. the SAM and BAM file formats).

- Renaming a file and changing its file extension will not cause any error if the new file extension does not match the format of the contents
- Mismatch between file extension and format of contents may only be detected when the file is actively used by a program that relies on the file extension

## Exercise 2 - Files and directories part 2

1. Change into your obds course directory, **/project/obds/\<username>/**. 
2. Create a new directory called 1_linux and change directory into it. 
3. Copy **SRR2121685h_1.fastq** from **/project/obds/datashare/ltamon/1_linux/** to the current working directory.
4. View the file **SRR2121685h_1.fastq** on the command line (try `cat`, `wc`, `head` and `tail`, `more` and `less`). Also try viewing using a
terminal text editor (making sure not to save unintended edits). 
5. How many lines does the fastq have? How many reads does it have?
6. Copy the directory **/project/obds/shared/resources/1_linux/1_linux_intro/** to your working directory (using `-r` option).
7. Move **SRR2121685h_1.fastq** in your working directory to the copied directory.  
8. Change the permissions of your **manpage.txt** file so that only you have read and write permission
8. Create a new directory within your home directory called **obds**
9. Change into the obds directory & make a copy of **manpage.txt** called **copy.txt**
10. Open **copy.txt** in a terminal text editor (e.g. nano) and remove the ‘usage’ line
11. Rename the file to **edit.txt**
12. Create a symbolic link to **SRR2121685h_1.fastq** called **symlink.fastq**, and a hard link called **hardlink.fastq**. Inspect files with `ls`. View the fastq again using the links. 
13. Delete both links at the same time.
14. Compare the output of these two commands.
15. Delete the obds directory, try using `rmdir` then `rm`. 

## Using octal notation for file permissions

- Octal notation is more compact but takes more practice to read and write
- Each type of permission is assigned a numerical value
  + 4 for **read** permission
  + 2 for **write** permission
  + 1 for **execute** permission
- We sum the numbers for each category to give a single unique number for each combination of permissions
- Each permissions category (owner, group, other) is represented by a number between 0 (no permission) and 7 (all permission)

## Changing file permissions using octal notation

- We can change file permissions with ``chmod`` using octal notation

```
$ chmod 700 file1.txt
$ ls -l file1.txt
-rwx------ 1 dsims obds 2981 Apr 26  2021 file1.txt
```

## Displaying file permissions in octal notation

- File permissions can be displayed in octal format using ``stat``
```
stat -c "%a: %n" *              # %a: access rights in octal, %n: file name
755: jupyter_notebooks
644: mm10.blacklist.bed.gz
```

## Advanced Exercise 3

1. Look up the usage of the `stat` command.
2. Display the octal permission for all the files and directories in your home directory.
3. Create a new text file called **test.txt** and set the file permissions to allow read, write and execute access for user only using octal notation.

## Useful links

- [Classic SysAdmin: The Linux Filesystem Explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained)

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

