# Talk 2: Introduction to the Linux command line

## Overview

- Linux is a type of computer operating system (OS), like Windows or MacOS, that is part of the Unix 
family of OS

<!--
- Linux is frequently used in high-performance computing and applications e.g. in Computational Biology
-->

<br>
<br> 

:::: {.columns}

::: {.column width="60%"}

- Introduction to the Linux shell 
- Using and getting help with Linux commands 
- Navigating the Linux file system
- Viewing and editing files
- Remote connection a Linux server or cluster
- File properties and permissions
- Manipulating files and directories

:::

::: {.column width="40%"}
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/UNIX-Logo-500x281.jpg")
```

<br>
<br>

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/linux-logo/
knitr::include_graphics("img/Symbol-Linux.jpg")
```
:::

::::

## Linux shell - Terminology alert!

<!-- 
Nice explanation in https://www.freecodecamp.org/news/command-line-for-beginners/ and
https://www.freecodecamp.org/news/the-linux-commands-handbook/#introductiontolinuxandshells
-->

- Linux is an Operating System (OS), like MS Windows and macOS, but open source (source code is freely available!) 
- All OS have a  **shell** (a command-line interpreter) for us to communicate with the OS
  + The **shell** takes commands from the keyboard and gives them to the OS to perform
- There are different shells differing in syntax and characteristics

## Linux shell - Terminology alert!

- Most widely used shell for Linux is **Bash** (Bourne Again Shell)
- A **terminal emulator** (e.g. Git Bash, macOS Terminal app) is used to interact with the shell, providing the **command-line interface (CLI)**, where user inputs commands
  + The command-line prompt (input field) is indicated by a certain character depending on the OS ($ for Linux)

:::: {.columns}

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_bash.png")
```
:::

::: {.column width="50%"}

```{r, linux_shell_emulator}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_emulator.png")
```
:::

::::

## Anatomy of a Linux command

- Basic part/s
  + \<command>      
  + \<command> \<argument> 
  + \<command> \<options> \<argument> 

- Types of commands
  + **Shell builtin** - Built into the shell itself
  + **Executable program** - Any external software in the system path (where OS looks for executable programs)
  + **Alias** - User-defined command built using other commands (To Be Discussed)

```
$ type cd               # ‘type’ shows the type of command
cd is a shell builtin

$ type head
head is /usr/bin/head
      
$ which head            # ‘which’ returns the path of the file to be executed
/usr/bin/head
```

## Anatomy of a Linux command

```
$ type cd               # ‘type’ shows the type of command
cd is a shell builtin

$ type head
head is /usr/bin/head
      
$ which head            # ‘which’ returns the path of the file to be executed
/usr/bin/head
```

- <span style="color:red;">Note!</span>
  + \<arrows> - indicate that this part is to be replaced accordingly, removing also the arrows
  + '$' - indicates the command-line prompt (input field) and so it should not be included when typing the command
  
## Linux command options

- Commands have options that modify their functions
  + \<command> \<options> \<argument>
  + Short options start with '-' (TBD)
  + Long options start with '\-\-' (TBD)

<br>

```
$ which head
/usr/bin/head

$ which -a head         # -a to print all matching paths of each argument
/usr/bin/head
/bin/head
```

## Getting help with Linux commands

- Different ways
  + `man` shows manual pages of the command
  ```
  $ man head
  ```
  + Press 'q' to exit
  
```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 800px
## Source: screenshot from jade
knitr::include_graphics("img/man_head.png")
```

## Getting help with Linux commands

- Different ways
   + Commands often come with the help option, `--help`
   ```
   $ head --help
   ```
   + More concise than `man` output

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 600px
## Source: screenshot from jade
knitr::include_graphics("img/help_head.png")
```

## Getting help with Linux commands

- Different ways
  + Google search!
  + Use in combination with command-line ways for information compatible with your system

```{r}
#| fig-align: center
#| out-height: 350px
#| out-width: 600px
## Source: Google search! :>
knitr::include_graphics("img/google_head.png")
```

## Some useful keyboard shortcuts

- **Tab** - autocomplete (will prompt if ambiguous)
  + Predict rest of word (e.g. command or file path/name) based on first few typed characters
  
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 600px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/tab_autocompletion.png")
```

- **Up and down arrows** - Access history of commands
- **Control + c** - Abort current command
- **Control + a** - Go to start of line
- **Control + e** - Go to end of line
- **Control + l** - Clear screen 

<span style="color:green;">**DEMO**</span>

## Linux file system tree

- In Linux, everything is a file organised in a tree structure
- A directory is just a file containing names of other files
- All directories branch off from the **root** ('/') directory
- **home** ('~') is your personal (user) directory

```{r}
#| fig-align: center
#| out-height: 400px
#| out-width: 700px
## Source: https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained
knitr::include_graphics("img/linux_file_tree.png")
```

## Linux commands to navigate the file structure

- Basic commands

```
$ pwd                       # Show present working directory
/home/<user>                # When you log into the OBDS server, the working directory
                              is initially set to the user’s home directory
$ ls                 
Desktop  Documents  Downloads...

$ cd Desktop                # Change directory

$ pwd
/home/<user>/Desktop

$ cd ~                      # Change into your home directory
```

## Working with Paths 

Path is the location to a file

:::: {.columns}

::: {.column width="40%"}

- There are two types of paths, absolute and relative
- Absolute paths
  + Absolute paths always starts with the root directory ('/')
  + Given by `realpath`
  
    ```
    $ realpath foo
    /home/mthomas/class_stuff/foo
    ```
:::

::: {.column width="60%"}

```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/sample_working_tree.png")
```

:::

::::

## Working with Paths 

:::: {.columns}

::: {.column width="40%"}

- Relative paths 
  + Relative paths are relative to the current working directory or where your are currently
  + Does not start with '/'

    ```
    $ pwd 
    /home/mthomas/class_stuff/foo
    
    $ cd ../bar     # Go to bar
    $ cd ../../bin  # Go to bin
    ```

- Path shortcuts
  + .  (full stop)     current directory 
  + .. (2 full stops)  parent / previous directory
  + ~  (tilde)         home directory
  + /  (forward slash) root directory
  
:::

::: {.column width="60%"}
```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
```
:::

::::

## Working with Paths

- Tips
  + Prompt tells you your current working directory
  
  ```{r, linux_shell_emulator}
  #| fig-align: center
  ```
  + Always use tab autocompletion to avoid typos 
  + `ls` output can be set to be coloured to indicate the type of each file 
    - <span style="color:indigo;">Directory</span>
    - File
    - <span style="color:cyan;">Symbolic link</span> (TBD) 
    - <span style="color:#b84e38;">Compressed file</span> (TBD)
    
## Viewing text files on the command line

- Useful commands
  + \<filename> - input file path or name (if file is in current working directory)

```
$ cat <filename>            # Print the entire file contents to the terminal
                            # If taking a while, interrupt with Control + c
$ head -n 20 <filename>     # Print the first n lines to the terminal (default=10)
$ tail -n 20 <filename>     # Print the last n lines to the terminal (default=10)
$ wc <filename>             # Count the number of characters (-m), lines (-l) etc.
```

- Interactively scroll through files

```
$ more <filename>           # Scroll through a file unidirectionally from top to 
                              bottom
$ less <filename>           # Like more but allows backward movement, "less is more"

                            # Up and down arrow keys to scroll one line up or down
                            # Left and right arrow keys to scroll one screen worth 
                              left or right across contents
                            # Unlike more, reaching end will not terminate 
                              interactive viewer
```

 + For both `more` and `less`
   - Use space bar to scroll down one screen worth of contents
   - Exit anytime with 'q'
   
# Coffee break (20 mins)

<!-- @sec-Talk2Exercise1 -->

## Remote connection to a Linux server

We will do exercises on the Linux OBDS teaching server so how to connect to it?
<br>

- We can log into a remote target host (e.g. server or cluster) using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure remote connection to a target host
  + The protocol uses a username and password to authenticate a user on the target host
 
## Remote connection to a Linux server *via* a jump host

- Sometimes, the connection has to be through a jump (bastion / proxy) host as an intermediary or gateway for extra security

- To connect to the OBDS server (obds), one method is to connect to the University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)
 
  + <span style="color:red;">For people within the University, the username is your SSO for both hosts</span>
  + <span style="color:red;">In our case, the user accounts on bastion and obds remote hosts are the same</span>

- <span style="color:red;">Note that we do not always have to go through a jump host</span>
 
## Remote Connection to a Linux Server

- To log out from the remote hosts, use any of the following:
  + Type 'exit' and press the Return key
  + Type 'logout' and press the Return key
  + Press Control + d

<span style="color:green;">**Do together**</span>

<!-- ## Side note for tomorrow! -->

<!-- - Please download the [FileZilla Client](https://filezilla-project.org/download.php?platform=osx) for tomorrow's lecture -->

<!-- - We will use this program to transfer files between your local machine and a remote target host (e.g. OBDS server) -->

# Talk 2 Exercise 1 then Lunch break (60 mins)

<!-- @sec-Talk2Exercise1 -->

## Changing how you view files using ``ls`` options

:::: {.columns}

::: {.column width="50%"}

- Short options can be bundled
  ```
  $ ls -l -t -a -h -F

  $ ls -ltahF    
  ```
  + -l - Long format, displaying detailed information (e.g. permissions, size, timestamp of latest update)
  + -t - Sort files by modification time (newest first)
  + -a - Show hidden files
  + -h - Human readable numbers
  + -F - Append an indicator to the end of each listed name (e.g. '/' for a directory)

:::

<!-- ### Notes -->

<!-- Short options can be bundled, needs less typing but less readabable -->
<!-- Long options more readable and descriptive -->
<!-- Choosing what format to follow boils down mainly to preference -->

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 375px
#| out-width: 450px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_options.png")
```

:::

::::

## File properties and permissions

<!-- ### Notes -->

<!-- The owner does not have to be part of the group that owns the file. -->
<!-- The owner can modify owner permissions. -->
<!-- A member of the group that owns the file can modify group permissions. -->
<!-- Other users can modify permissions if the owner grants them that privilege. -->
<!-- You can have no read permission but still have write permission i.e. you can edit but you do not really see what's in the file (dangerous) -->

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output_labeled.png")
```

- `ls -l` used to display file permissions

## File permissions - owner

- Linux is a multi-user OS
- So important that access to read, write and execute each file or directory is controlled
- Each file is owned by exactly one **user**

```{r}
#| fig-align: center
#| out-height: 200px
#| out-width: 915px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output.png")
```

## File permissions – group & other

- A **group** is a collection of one or more users
- Each user can belong to multiple groups
- A file is owned by exactly one group
- To view your current user groups, use the command:
```
$ groups
```
- The last category that you can assign permissions for is the **other** category
  + Not the file owner and 
  + Not a member of the group that owns the file

## Types of file permissions

- Each permissions category (owner, group and other) can be assigned permissions that restrict their ability to read, write, or execute a file
- For a regular file
  + **Read** permissions are required to read the contents of a file (**open**)
  + **Write** permissions are necessary to **modify** it
  + **Execute** permissions are needed to **run the file** as a program
- For directories
  + **Read** permissions are necessary to **list** the contents of a directory
  + **Write** permissions are required to **modify** the contents of a directory
  + **Execute** permissions allow a user to **navigate** into the directory
- Linux represents these types of permissions using alphabetic or octal notations

## Alphabetic notation

- More verbose and easier to read and write than the octal notation

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 18)
knitr::include_graphics("img/alphabetic_notation.png")
```

## Changing file permissions using alphabetic notation

- Most commonly, changes in file permissions are made to
  + Strategically control access
  + Make valuable files (e.g. raw sequencing data) read-only, to avoid accidentally deleting them
  + Make script files executable
  
- Do not change file permissions to give other users access to your own files and directories
- Instead, contact the system administrators to request directories that are set up with shared access for collaborators 
<!-- (e.g. projects in the CCB cluster) -->
  
## Changing file permissions using alphabetic notation

- We can change file permissions with ``chmod`` using alphabetic notation
- `chmod` \<permissions> \<file or directory>
  + **u** for user, **g** for group, **o** for other
  + **--** to deny access, **+** to give access
  + **r** for read, **w** for write, **x** for execute
  + **,** (comma) for separating multiple sets of changes 

```
$ chmod u+x,g-w,o-r file1.txt
```
  + u+x - To add execute permission for the user who owns the file 
  + g-w - To remove write permission for the user group assigned to the file 
  + o-r - To remove read permission for every other user 

```
$ chmod go-rwx file1.txt    # Can be bundled together when applying same 
                              permission to user categories      
                              
$ ls -l file1.txt
-rwx------ 1 dsims root 2981 Apr 26  2020 file1.txt
```

## Viewing and editing files on the command line using interactive text editors

- No graphical interface or mouse required
- Tools
  + Vim
    - Development started in 1988, widely used, large number of add-ons
    - Can be heavily customised (e.g. keyword highlighting, code auto-completion)
    - But users need to learn a set of keyboard shortcuts
  + Nano -  relatively newer, more basic and so recommended for beginners
- To edit a file, type:
  ```
  $ nano <filename>
  ```

## Working with nano

<span style="color:green;">**DEMO**</span>

- The arrow keys can be used to move the cursor through the file
- Common keyboard shortcuts are displayed at the bottom of the editor
  + The ^ symbol represents the Control key
  + For instance, ^X indicates that pressing the Control + x will exit the interactive text editor
  + Control + k - to delete/cut a line
  + Control + w - to search for a text
  + Control + w + v - to go to end of document

- To save edits made to a file:
  + Press Control + x to initiate the exit from the editor
  + When prompted whether to ‘Save modified buffer’, press Y to confirm (N to discard changes)
  + When prompted for the ‘File Name to Write’, immediately press the Return key to use the current
  file name (or edit file name as needed)
  
## Creating files and directories

<br>

```
$ touch <filename>      # Create new empty file (can create several at a time)
                        # If file exists, will update timestamp to current time
                            
$ nano <filename>       # Open new empty file in nano editor
                        # If file exists, will open file for editing
                                
$ mkdir <dir1>          # Create new directory
$ mkdir <dir1> <dir2>   # Create multiple new directories
```

## Copying, moving and renaming files

<br>

```
$ cp file1 file2                # Copy file to new file
$ cp -n file1 file2             # Do not overwrite if file2 exists
$ cp file1 dir1/                # Copy file to new directory
$ cp -r dir1/ dir2/             # 'cp' needs -r to recursively copy contents of 
                                  directories (empty or not) to a new directory 
                                  (does not need to exist beforehand)
                                # If dir2/ already exists, the copy will be 
                                  created inside dir2/


$ mv file1 file1.csv            # Rename file
$ mv file1 dir1/file.csv        # Move file to new directory and rename 
                                  (-n to not overwrite)
$ mv dir1/ dir2/                # Rename directory, no need for -r
                                # But if dir2/ exists, dir1/ will be moved to dir2/ 
```

## Deleting files & directories 

<br>

```
$ rm file1                              # Remove file
$ rm file1.txt file1.csv file2* *.csv   # Remove multiple files, use wildcard (*)
                                        # Also delete all files whose names start with 
                                          file2 and all files that end with .csv
$ rm -r dir1                            # Remove directory and contents     
$ rm -rv dir1                           # Verbosely display list of files to be removed
$ rmdir dir1                            # Remove empty directory, will raise an 
                                          error if directory is not empty
$ rmdir dir1 dir2                       # Will only remove empty directories
```

- **<span style="color:red;">There is no undo or recycle bin so be careful when using `rm` !</span>**
  + Particularly with -r (recursive) or '*' (wildcard)
  + **<span style="color:green;">Good news</span>**, you can only remove files you have permission to delete
  
- **<span style="color:green;">Make sure to try the commands you have seen on your own later!</span>**

## Using wildcards (*)

- Wildcards are special characters that match one or more characters in filenames
- Therefore they are used to specify groups of file names matching a pattern
- Main wildcards
  + \* - Matches any sequence of characters 
  + ? - Matches any single character

<!-- - Example globs (term used in Linux): -->
```
$ ls *.jpg                      # Lists all files with the .jpg extension
$ ls sample1*                   # Lists all files which start with sample1
$ ls *temp*                     # Lists all files with temp anywhere in the file name
$ file?.*                       # Multiple wildcards can be used in the same pattern
```

## Hard & symbolic links to files and directories

- In cases when you need files to be in multiple places, links to files can be used instead of copying files in multiple places
  + Saves space
  + For more organised and logical file structures
  + Easier to keep files up to date across different places
- A **hard link** is a pointer to the data itself (spot on the hard drive)
- A **symbolic link** (soft link or abbreviated symlinks) is a file that contains a text pointer to the path of a file or directory
- Symbolic links overcome disadvantages of hard links:
  + Deleting all the hard links to a file will effectively delete the file itself
  + Hard links cannot span physical devices (a server or cluster can have multiple disks)
  + Hard links cannot reference directories but only files
- The advantage of hard links is that they remain working even when they are moved because they point to the data itself
- Symbolic link becomes unusable if original file is moved or deleted unless the path it points to is updated

## Hard & symbolic links to files and directories

- Symbolic links can point to target files using absolute or relative paths
  + When using absolute paths, symlink will keep working even if it's moved
  + When using relative paths (relative to location of symlink), symlink will not work when it is moved

```
$ ln file1 link1.csv            # Create hard link
$ ln -s file1 link1.csv         # Create symbolic link for a file
$ ln -s dir1 link1              # Create symbolic link for a directory
```

## File types and extensions
 
- Files can be:
  + Plain text - contain only characters of readable materials that can be displayed by most text editors
  + Binary - not plain text (e.g. compiled programs, images)
- Many files follow a standardised internal organisation known as a file format
  + Ensures consistency
  + Enables programs to easily extract defined information
- Adding a file extension can indicate the file format
- Programs often rely on file extensions in input and output file names
  + Input: To parse file contents based on their format
  + Output: To indicate the format used to write file contents

- Good habit to use an appropriate file extension even just using the generic '.txt' to indicate that the file contains plain text information

## File types and extensions

- There are several biological file formats
  + .fasta - biological sequence information
  + .fastq (.fq) - sequence information with quality scores
  + .sam, .bam - alignments of sequences to a reference genome
  + .gtf, .bed - genomic coordinates of sequence features (e.g. exons, peaks)
- In bioinformatics, binary formats (e.g., BAM, CRAM) are commonly used to compress equivalent plain text files

- Changing the file extension itself does not alter the actual content of the file
  + But a mismatch of file format and file extension may cause errors if a program expects a specific format based on the extension
  
# Coffee break (20 mins) then Talk 2 Exercise 2

<!-- @sec-Talk2Exercise2 -->

<br>

Talk 2 Advanced Exercise 3 - Octal permissions

## Useful links

- [Classic SysAdmin: The Linux Filesystem Explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained)

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

# Advanced topics

## Using octal notation for file permissions

- Octal notation is more compact but takes more practice to read and write
- Each type of permission is assigned a numerical value
  + **4** for **read** permission
  + **2** for **write** permission
  + **1** for **execute** permission
- We sum the numbers for each category to give a single unique number for each combination of permissions
- Each permissions category (owner, group, other) is represented by a number between **0** (no permission) and **7** (all permission)

## Changing file permissions using octal notation

- We can change file permissions with ``chmod`` using octal notation

  ```
  $ chmod 700 file1.txt
  $ ls -l file1.txt
  -rwx------ 1 dsims obds 2981 Apr 26  2021 file1.txt
  ```

- File permissions can be displayed in octal format using ``stat``

  ```
  stat -c "%a: %n" *              # %a: access rights in octal, %n: file name
  755: jupyter_notebooks
  644: mm10.blacklist.bed.gz
  ```
  + -c - use the specified format instead of the default