# Talk 2: Introduction to the Linux command line

## Overview

<!--
- Linux is a type of computer operating system (OS), like Windows or MacOS, that is part of the Unix family of OS
- Linux is frequently used in high-performance computing and applications e.g. in Computational Biology
-->

:::: {.columns}

::: {.column width="60%"}

- Introduction to the Linux shell 
- Linux commands 
- Navigating the Linux file system
- Viewing and editing files
- File properties and permissions
- Copying, moving and renaming files and directories
- Hard and symbolic links
- Deleting files and directories
  
:::

::: {.column width="40%"}
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/UNIX-Logo-500x281.jpg")
```

<br>
<br>

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/linux-logo/
knitr::include_graphics("img/Symbol-Linux.jpg")
```
:::

::::

## Linux shell - Terminology alert!

<!-- 
Nice explanation in https://www.freecodecamp.org/news/command-line-for-beginners/ and
https://www.freecodecamp.org/news/the-linux-commands-handbook/#introductiontolinuxandshells
-->

- Linux is an Operating System (OS), like MS Windows and macOS, but open source (source code is freely available!) 
- All OS have a  **shell** i.e. a command-line interpreter
  + It processes the commands, giving them to the OS and outputs the results
- There are different shells differing in syntax and characteristics

## Linux shell - Terminology alert!

- Most widely used shell for Linux is **Bash** (Bourne Again Shell)
  + Default shell in the OBDS cluster but others are available for use
- A **terminal emulator** (e.g. Git Bash, Terminal) is used to interact with the shell, providing the **command-line interface (CLI)**, where user inputs commands
  + The command-line prompt (input field) is indicated by a certain character depending on the OS ($ for Linux)

:::: {.columns}

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_bash.png")
```
:::

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_emulator.png")
```
:::

::::

## Linux commands

- Basic part/s (<span style="color:red;">\<arrows></span> indicates a variable which should be replaced)
  + \<command>      
  + \<command> \<argument> 
  + \<command> \<options> \<argument> 
  
- Types
  + **Shell builtin** - Built into the shell itself
  + **Executable program** - Any external software in the system path (where OS looks for executable programs)
  + **Alias** - User-defined command built using other commands (To Be Discussed)

```
$ type cd               # ‘type’ shows the type of command
cd is a shell builtin

$ type head
head is /usr/bin/head
      
$ which head            # ‘which’ returns the path of the file to be executed
/usr/bin/head
```

## Linux command options

- Commands have options that modify their functions
  + \<command> \<options> \<argument>
  + Short options start with '-' (TBD)
  + Long options start with '\-\-' (TBD)

<br>

```
$ which head
/usr/bin/head

$ which -a head         # -a to print all matching paths of each argument
/usr/bin/head
/bin/head
```

## Some useful Bash keyboard shortcuts

- **Tab** - autocomplete (will prompt if ambiguous)
  + Predict rest of word (e.g. command or file path/name) based on first few typed characters
  
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 600px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/tab_autocompletion.png")
```

- **Up and down arrows** - Access history of commands
- **Control + c** - Abort current command
- **Control + a** - Go to start of line
- **Control + e** - Go to end of line

**DEMO**

## Getting help with linux commands

- Different ways
  + `man` shows manual pages of the command
  + Press 'q' to exit

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 800px
## Source: screenshot from jade
knitr::include_graphics("img/man_head.png")
```

## Getting help with linux commands

- Different ways
   + `--help`
   + Different format with `man`

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 600px
## Source: screenshot from jade
knitr::include_graphics("img/help_head.png")
```

## Getting help with linux commands

- Different ways
  + Google search!
  + Use in combination with command-line ways for more information that is accurate and up to date

```{r}
#| fig-align: center
#| out-height: 350px
#| out-width: 600px
## Source: Google search! :>
knitr::include_graphics("img/google_head.png")
```

## Linux file system tree

- In Linux, everything is a file organised in a tree structure
- A directory is just a file containing names of other files
- All directories branch off from the **root** directory
- **home** is your personal (user) directory

```{r}
#| fig-align: center
#| out-height: 400px
#| out-width: 700px
## Source: https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained
knitr::include_graphics("img/linux_file_tree.png")
```

## Commands to navigate the file structure

- Basic commands

```
$ type cd                   # ‘type’ shows the type of command
$ pwd                       # Print working directory
/home/<user>                # When you log into the CCB cluster, the working directory
                              is initially set to the user’s home directory
$ ls                 
Desktop  Documents  Downloads...

$ cd Desktop                # Change directory

$ pwd
/home/<user>/Desktop
```

## Working with Paths 

Path is the location to a file

:::: {.columns}

::: {.column width="40%"}

- Absolute paths
  + Absolute paths always starts with the root directory ('/')
  + Given by `realpath`
  
    ```
    $ realpath foo
    /home/mthomas/class_stuff/foo
    ```
:::

::: {.column width="60%"}

```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/sample_working_tree.png")
```

:::

::::

## Working with Paths 

:::: {.columns}

::: {.column width="40%"}

- Relative paths 
  + Relative paths are relative to the current working directory
  + Does not start with '/'

    ```
    $ pwd 
    /home/mthomas/class_stuff/foo
    
    $ cd ../bar     # Go to bar
    $ cd ../../bin  # Go to bin
    ```

- Path shortcuts
  + .  (full stop)     current directory 
  + .. (2 full stops)  parent directory
  + ~  (tilde)         home directory
  + /  (forward slash) root directory
  
:::

::: {.column width="60%"}
```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
```
:::

::::

## Working with Paths

- Tips
  + Prompt tells you your current working directory
  + Always use tab autocompletion to avoid typos 
    - Command-line interpreters may figure out whether you need a command or file path
  + `ls` output can be set to be coloured to indicate the type of each file 
    - <span style="color:indigo;">Directory</span>
    - File
    - <span style="color:cyan;">Symbolic link</span> (TBD) 
    - <span style="color:#b84e38;">Compressed file</span> (TBD)
    
## Viewing text files on the command line

- Useful commands

```
$ cd ../bar                      
$ cat <filename>            # Print the entire file contents to the terminal
                            # If taking a while, interrupt with Control + c
$ head -n 20 <filename>     # Print the first n lines to the terminal (default=10)
$ tail -n 20 <filename>     # Print the last n lines to the terminal (default=10)
$ wc <filename>             # Count the number of bytes (-m), characters (-m), 
                              lines (-l) etc.
```

- Interactively scroll through files

```
$ more <filename>           # Scroll through a file unidirectionally from top to 
                              bottom
$ less <filename>           # Like more but allows backward movement, "less is more"
                            # Up and down arrow keys to scroll one line up or down
                            # Left and right arrow keys to scroll one screen worth 
                              left or right across contents
                            # Similar to more, use space bar to scroll down one 
                              screen worth of contents
                            # Unlike more, reaching end will not terminate 
                              interactive viewer
                            # Similar to more, exit anytime with 'q'
```

## Remote connection to a Linux server

- We can log into a remote target host using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure remote connection to a target host
- Simply put, the protocol uses a username and password to authenticate a user on the remote target host

```
$ ssh <target username>@<target host>
```
  + If prompted whether to continue connecting, type 'yes' (usually appears when connecting the first time)
  + This prompts for the password for the user account on target host 

## Remote connection to a Linux server *via* a jump host

- Sometimes, the connection has to be through a jump (bastion / proxy) host as an intermediary or gateway for extra security

```
$ ssh -J <jump username>@<jump host> <target username>@<target host>  
```

- We will be using the new OBDS teaching server throughout the Linux course. To connect to the server (obds), we need to use University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)

```
$ ssh -J <username>@bastion.imm.ox.ac.uk <username>@obds
```

-
  + This prompts for 2 passwords, 1 for the jump host and 1 for the target host, that should be entered every time you want to connect

  + <span style="color:red;">For people within the University, the username is your SSO for both hosts</span>
  
## Remote Connection to a Linux Server

- For the very first connection, you may be prompted to verify the authenticity of the host
  + Type 'yes' and press the Return key to continue connecting

- When prompted for your password, type it and press the Return key

- To logout, use any of the following:
  + Type 'exit' and press the Return key
  + Type 'logout' and press the Return key
  + Press Control + d

## Side note for tomorrow!

- Please download [FileZilla Client](https://filezilla-project.org/download.php?platform=osx) for tomorrow's lecture

- We will use this program to transfer files between your local machine and a remote host (OBDS server)

# Talk 2 Exercise 1 – Files and directories part 1

## Changing how you view files using ``ls`` options

:::: {.columns}

::: {.column width="50%"}

- Short options can be bundled

```
$ ls -l -t -a -h -F

# Short options can be bundled
$ ls -ltahF    
```
  + -l - Long format, displaying detailed information (e.g. permissions, size, timestamp of latest update)
  + -t - Sort files by modification time (newest first)
  + -a - Show hidden files
  + -h - Human readable numbers
  + -F - Append an indicator to the end of each listed name (e.g. '/' for a directory)

```
$ ls --help
$ man ls
```

:::

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 415px
#| out-width: 450px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_options.png")
```

:::

::::

## File properties and permissions

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output_labeled.png")
```

- `ls -l` used to display file permissions

## File permissions - Owner

- Linux is a multi-user operating system
- Access to read, write and execute each file or directory is controlled
- Each file is owned by exactly one user

```{r}
#| fig-align: center
#| out-height: 200px
#| out-width: 900px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output.png")
```

## File permissions – group & other

- A group is a collection of one or more users
- Each user can be a member of multiple groups 
- A file can be owned by exactly one group
- To see the groups that your user currently belongs to, type:
```
$ groups
```
- The last category that you can assign permissions for is the **‘other’** category
  + Any user that is not the file owner and 
  + is not a member of the group that owns the file
- This allows you to set permissions that will apply to anyone outside of the two control groups
  + Any user that is not the file owner and
  + is not a member of the group that owns the file

## Types of permissions

- Each permissions category (owner, group and other) can be assigned permissions that restrict their ability to read, write, or execute a file
- For a regular file
  + **Read** permissions are required to read the contents of a file (**open**)
  + **Write** permissions are necessary to **modify** it
  + **Execute** permissions are needed to **run the file** as a program
- For directories
  + **Read** permissions are necessary to **list** the contents of a directory
  + **Write** permissions are required to **modify** the contents of a directory
  + **Execute** permissions allow a user to **navigate** into the directory
- Linux represents these types of permissions using alphabetic or octal notations

## Alphabetic notation

- More verbose and easier to read and write than the octal notation

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 18)
knitr::include_graphics("img/alphabetic_notation.png")
```

## Changing file permissions using alphabetic notation

- Most commonly, changes in file permissions are made to
  + Make script files executable
  + Make valuable files (e.g. raw sequencing data) read-only, to avoid accidentally deleting them
  
- Do not change file permissions to give other users access to your own files and directories
- Instead, contact the system administrators to request project directories that are set up with shared access for collaborators
  
## Changing file permissions using alphabetic notation

- We can change file permissions with ``chmod`` using alphabetic notation
- `chmod` <permissions> <file or directory>
  + u - For user, g for group, o for other
  + - - To deny access, + to give access
  + r - For read, w for write, x for execute
  + , - For separating multiple sets of changes 

```
$ chmod u+x,g-w,o-r file1.txt
```
  + u+x - To add execute permission for the user who owns the file 
  + g-w - To remove write permission for the user group assigned to the file 
  + o-r - To remove read permission for every other user 

```
$ chmod go-rwx file1.txt    # Can be bundled together when applying same 
                              permission to groups       
                              
$ ls -l file1.txt
-rwx------ 1 dsims root 2981 Apr 26  2020 file1.txt
```
## Viewing and editing files on the command line using interactive text editors

- No graphical interface or mouse required
- Tools
  + Vim and Emacs 
    - Been around for 40 years, widely used, large number of add-ons
    - Can be heavily customised (e.g. keyword highlighting, code auto-completion)
    - But users need to learn a set of keyboard shortcuts
  + Nano - more basic and so recommended for beginners
- To edit a file, type either one of these
```
$ vim <filename>  
$ emacs <filename>
$ nano <filename>
```

## Creating files and directories

<br>

```
$ touch <filename>      # Create new empty file (can create several at a time)
                        # If file exists, will update timestamp to current time
                            
$ nano <filename>       # Open new empty file in nano editor
                        # If file exists, will open file for editing
                                
$ mkdir <dir1>          # Create new directory
$ mkdir <dir1> <dir2>   # Create multiple new directories
```

## Working using nano

- The arrow keys can be used to move the cursor through the file
- Common keyboard shortcuts are displayed at the bottom of the editor
  + The ^ symbol represents the Control key
  + For instance, ^X indicates that pressing the Control + x will exit the interactive text editor

- To save edits made to a file:
  + Press the Control and X keys simultaneously to initiate the exit from the editor
  + When prompted whether to ‘Save modified buffer’, press Y to confirm (N to discard changes)
  + When prompted for the ‘File Name to Write’, immediately press the Return key to use the current
  file name (or edit file name as needed)

## Copying, moving and renaming files

<br>

```
$ cp file1 file2                # Copy file to new file
$ cp -n file1 file2             # Do not overwrite if file2 exists
$ cp file1 dir1/                # Copy file to new directory
$ cp -r dir1/ dir2/             # 'cp' needs -r to recursively copy contents of 
                                  directories (empty or not) to a new directory 
                                  (does not need to exist beforehand)
                                # If dir2/ already exists, the copy will be 
                                  created inside dir2/


$ mv file1 file1.csv            # Rename file
$ mv file1 dir1/file.csv        # Move file to new directory and rename 
                                  (-n to not overwrite)
$ mv dir1/ dir2/                # Rename directory, no need for -r
                                # But if dir2/ exists, dir1/ will be moved to dir2/ 
```

## Deleting files & directories 

<br>

```
$ rm file1                              # Remove file
$ rm file1.txt file1.csv file2* *.csv   # Remove multiple files, use wildcard (*)
                                        # Also delete all files whose names start with 
                                          file2 and all files that end with .csv
$ rm -r dir1                            # Remove directory and contents     
$ rm -rv dir1                           # Verbosely display list of files to be removed
$ rmdir dir1                            # Remove empty directory, will raise an 
                                          error if directory is not empty
$ rmdir dir1 dir2                       # Will only remove empty directories
```

- **<span style="color:red;">There is no undo or recycle bin so be careful when using `rm` !</span>**
  + Particularly with -r (recursive) or '*' (wildcard)
  + **<span style="color:green;">Good news</span>**, you can only remove files you have permission to delete
  
## Using wildcards (*)

- Wildcards are special characters that match one or more characters in filenames
- Therefore they are used to specify groups of file names matching a pattern
- Main wildcards
  + \* - Matches any sequence of characters 
  + ? - Matches any single character

- Example globs (term used in Linux):
```
$ ls *.jpg                      # Lists all files with the .jpg extension
$ ls sample1*                   # Lists all files which start with sample1
$ ls *temp*                     # Lists all files with temp anywhere in the file name
$ file?.*                       # Multiple wildcards can be used in the same pattern
```

## Hard & symbolic links to files and directories

- A hard link is an additional name for an existing file
- A symbolic link (soft link or abbreviated symlinks) is a file that contains a text pointer to a target file or directory
- Symbolic links overcome disadvantages of hard links:
  + Deleting all the hard links to a file will effectively delete the file itself
  + Hard links cannot span physical devices (disks and the CCB cluster is composed of many nodes and disks)
  + Hard links cannot reference directories but only files
- The advantage of hard links is that the original and linked files remain linked even when either or both files are moved
- Symbolic links become unusable if target file is moved or deleted unless they are updated

## Hard & symbolic links to files and directories

- Symbolic links can point to target files using absolute or relative paths (relative to location of symlink)
  + With absolute paths, symlink will continue to point to the same location even if the symlink itself is moved
  + With relative paths, symlink will point to a new location if the symlink itself is moved (relative to new location of symlink)

```
$ ln file1 link1.csv            # Create hard link
$ ln -s file1 link1.csv         # Create symbolic link
$ ln -s dir1 link1              # Create symbolic link
```

- **Do not create hard links on the CCB cluster. If you think you need a hard link, contact system administrators first to enquire**

## File types and extensions
 
- Files can be:
  + Plain text - contain only characters of readable materials that can be displayed by most text editors
  + Binary - not plain text (e.g. compiled programs, images)
- Many files use a standardised internal organisation called a file format
  + Having a standard allows for consistency
  + Enables software to easily extract defined information
- Many programs make use of file extensions in their input and output file names:
  + To parse the contents of input files according to their format 
  + To indicate the format used to write the contents of their output files

- Good habit to use an appropriate file extension even just using the generic '.txt' to indicate that the file contains plain text information

## File types and extensions

- There are several biological file formats
  + .fasta - biological sequence information
  + .fastq (.fq) - sequence information with quality scores
  + .sam, .bam - alignments of sequences to a reference genome
  + .gtf, .bed - genomic coordinates of sequence features (e.g. exons, peaks)
- In bioinformatics, binary file formats are commonly used to store compressed versions of equivalent plain text files (e.g. the SAM and BAM file formats).

- Renaming a file and changing its file extension will not cause any error if the new file extension does not match the format of the contents
- Mismatch between file extension and format of contents may only be detected when the file is actively used by a program that relies on the file extension

# Talk 2 Exercise 2 - Files and directories part 2

## Using octal notation for file permissions

- Octal notation is more compact but takes more practice to read and write
- Each type of permission is assigned a numerical value
  + **4** for **read** permission
  + **2** for **write** permission
  + **1** for **execute** permission
- We sum the numbers for each category to give a single unique number for each combination of permissions
- Each permissions category (owner, group, other) is represented by a number between **0** (no permission) and **7** (all permission)

## Changing file permissions using octal notation

- We can change file permissions with ``chmod`` using octal notation

```
$ chmod 700 file1.txt
$ ls -l file1.txt
-rwx------ 1 dsims obds 2981 Apr 26  2021 file1.txt
```

## Displaying file permissions in octal notation

- File permissions can be displayed in octal format using ``stat``
```
stat -c "%a: %n" *              # %a: access rights in octal, %n: file name
755: jupyter_notebooks
644: mm10.blacklist.bed.gz
```

## Advanced Exercise 3

1. Look up the usage of the `stat` command.
2. Display the octal permission for all the files and directories in your home directory.
3. Create a new text file called **test.txt** and set the file permissions to allow read, write and execute access for user only using octal notation.

## Useful links

- [Classic SysAdmin: The Linux Filesystem Explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained)

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

