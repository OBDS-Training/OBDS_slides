---
title: "Solution: Single-cell integration"
author: "Kevin Rue-Albrecht & Liezel Tamon"
date: "2024-04-26"
---

```{r}
#| label: load-packages
#| include: false
library(Seurat)
```

## Preamble

Refer to the vignette [Integrative analysis in Seurat v5](https://satijalab.org/seurat/articles/seurat5_integration#perform-streamlined-one-line-integrative-analysis) for guidance throughout the workflow.
Some of the functions required for this workflow are only mentioned in this vignette and not documented in the Seurat package itself.

## Import data sets to integrate

- Use `readRDS()` to import two prefiltered PBMC data sets from the files `pbmcv1_filtered.rds` and `pbmcv2_filtered.rds`.

```{r}
pbmv1 <- readRDS("data/pbmcv1_filtered.rds")
pbmv2 <- readRDS("data/pbmcv2_filtered.rds")
```

Those RDS files contain objects that have been preprocessed through quality control and filtering, as demonstrated in the Seurat day 1 lesson.

## Prepare the data sets for integration

- Use `merge()` to combine the two Seurat objects into a single object.

```{r}
obj <- merge(pbmv1, pbmv2)
```

In previous versions of Seurat, the integration workflow would have required the data to be represented as distinct Seurat objects.
When using Seurat version 5 assays, we can instead keep all the data in one object, but simply split the layers.

- Display the merged Seurat object.

```{r}
obj
```

**How do you interpet the 'layer' information?**

> Answer:
> 
> Each layer represents one data set.

## Integration without correction

- Use the functions `NormalizeData()`, `FindVariableFeatures()`, `ScaleData()`, and `RunPCA()` to performed a standard Seurat analysis without integration.

```{r}
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
```

- Use the functions `FindNeighbors()` and `FindClusters()` to compute cluster labels.

**Hint:**

- For `FindNeighbors()`, use arguments `dims = 1:30` and `reduction = "pca"`.
- For `FindClusters()`, use arguments `resolution = 2`, `cluster.name = "unintegrated_clusters"`.

```{r}
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 2, cluster.name = "unintegrated_clusters")
```

- Use `table()` to tabulate the number of cells in each cluster.

```{r}
table(obj$unintegrated_clusters)
```

- Use `RunUMAP()` to compute a UMAP layout.

**Hint:**

- Use argument `dims = 1:30`, to match the number of principal components used for clustering.
- Use argument `reduction = "pca"`, to match the input data used for clustering.
- Use argument `reduction.name = "umap.unintegrated"`, to distinguish this UMAP from the ones we will compute later with integration.

```{r}
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")
```

- Use `DimPlot()` to display the unintegrated UMAP layout.

**Hint:**

- Use the argument `group.by = "orig.ident"` to colour by experiment.

```{r}
# visualize by batch and cell type annotation
# cell type annotations were previously added by Azimuth
DimPlot(obj, reduction = "umap.unintegrated", group.by = "orig.ident")
```
