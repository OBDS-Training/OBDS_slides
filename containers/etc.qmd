# What are containers?

## What are containers?

- Consistent, reproducible environments.
- Bundles of code, libraries, and dependencies.
- Secure environments separated from data on the host system.

```{r}
#| fig-cap: "Illustration of a container isolating software on a host (Source: Kevin Rue)."
knitr::include_graphics("img/containers-draft-02-slide-04.svg")
```

## Multiple containers isolate software on a single host

```{r}
#| fig-cap: "Illustration of multiple containers on a single host (Source: Kevin Rue)."
knitr::include_graphics("img/containers-draft-02-slide-05.svg")
```

## Reproducible Research

### Containers

- Contain all code dependencies including operating system dependencies.
- Can reproduce the exact same environment on different host operating systems.

### For comparison

- [Conda](https://anaconda.org/anaconda/conda) only reproduces installed software
  but has different sets of dependencies for different operating systems.

# Using Containers

## Containers Engines

### Docker

- One of the first and most famous.
- **Caveat:** requires administrator permissions to run.

### Singularity

- Gained popularity over Docker thanks to the absence of administrator requirement.

### Apptainer

- A fork of Singularity.
  Chosen for JADE cluster and OBDS server.

## Containers: Images and Definition Files

### Image Files

Container images use the `*.sif` file extension.

- Those are the files that contain the actual data.

### Definition Files

Container definitions use the `*.def` extension.

- Those are scripts that describe the container and were used to create the corresponding image files.

::: {.callout-note}
In this lesson, we will initially use existing images to run commands before writing our own definitions and creating our own images.
:::

## Containers on JADE

The IT team of the JADE cluster prepared a small set of containers that can help you get started.

They can be found in the directory `/package/containers/`.

```
/package/containers/
│
├── centos          # CentOS container, mimics previous cluster
├── ubuntu          # Basic Ubuntu container, mimics JADE
├── R-4.3.0         # Ubuntu + R 4.3.0
├── rstudio-server  # R 4.3.0 + RStudio Server
├── miniforge       # Ubuntu + Miniforge
└── builder         # Ubuntu + compilers & libraries
```

## Containers on OBDS

On OBDS, we replicated some of those containers (and more) in preparation for the exercises.

They can be found in the directory `/project/shared/resources/containers/`.


```
/project/shared/resources/containers/
├── builder
│   ├── builder.def
│   └── builder.sif
├── fastqc
│   ├── fastqc.def
│   └── fastqc.sif
├── miniforge
│   ├── miniforge.def
│   └── miniforge.sif
├── samtools
│   ├── samtools.def
│   └── samtools.sif
└── ubuntu-22
    ├── ubuntu-22.def
    └── ubuntu-22.sif
```

## Using Containers

Given a container file, Apptainer commands can execute commands in the container in various ways.

For instance, the following commands both launch a Bash shell within the given container.

### shell

The `shell` sub-command specifically opens an interactive shell in the given container:

```bash
apptainer shell /project/shared/resources/containers/ubuntu-22/ubuntu-22.sif
```

### exec

The `exec` sub-command execute any given command in the given container:

```bash
apptainer exec /project/shared/resources/containers/ubuntu-22/ubuntu-22.sif bash
```

::: {.callout-note}
In practice, both can provide a Bash shell, but `shell` is explicitly intended for interactive use, while `exec` is more suited for single-command execution
:::

## Support for Docker Images

Apptainer can also run Docker images from online repositories.

```bash
apptainer exec docker://ubuntu:22.04 bash
```

Apptainer caches downloaded containers to the user’s home directory.

To avoid quota issues, change the cache location in your `.bash_aliases`.

```bash
export APPTAINER_CACHEDIR=/project/example/myname/mycontainers
```

## Accessing Data on the Host System

Containers mainly provide software.

Containers must be given controlled access to the host system for:

- Accessing input data files
- Storing output data files

Access to specific directories is given by 'mounting' (also known as 'binding') the relevant directories on the host system to specific paths accessible from within the container.

## Mounting (or Binding)

### Example

```bash
apptainer exec -B /project/shared/resources /project/shared/resources/containers/ubuntu-22/ubuntu-22.sif bash 
```

- The `-B` option 'binds' a directory to the container.
- By default, containers can read and write to bounds directories,
  unless ‘read-only’ is specified^[<https://apptainer.org/docs/user/main/bind_paths_and_mounts.html>].
- Multiple directories can be bound to the same container, repeating the `-B` option as many times as necessary.

```bash
apptainer exec \
  -B /project/shared/resources \
  -B /project/$USER \
  /project/shared/resources/containers/ubuntu-22/ubuntu-22.sif bash 
```

## Exercise

In the container: `r-4.3.0.sif`

Execute the command:

```bash
R --version
```

### Hints

- Use the `apptainer exec` command.

## Exercise

In the container: `r-4.3.0.sif`

Execute the R script: `installed_packages.R`

### Hints

- Use the Bash command `Rscript`
- The full command should look like `Rscript /path/to/installed_packages.R`.
- The directory that contains the R script must be bound to the container,
  to be visible from inside the container.

## Exercise

In the Docker container accessible online:

```
bioconductor/bioconductor_docker:devel
```

Execute the R script: `installed_packages.R`

### Hints

- Before you run the `apptainer exec` command,
  make sure that the environment variable `APPTAINER_CACHEDIR` is set in your Bash session.
- The first time you run an `apptainer exec` command on a new remote container,
  the command will likely take a minute or two to download the container files.
  If you see messages like "Copying blob" and "info unpack layer",
  you are on the right track, keep waiting!

Visually compare the output (R version, list of packages) with the previous exercise.

## Exercise

In the container: `fastqc.sif`

Run the FastQC program on the input file `ERR1755082_1.fastq.gz`,
and direct the output to your own project directory.

### Hints

- In the container, the `fastqc` command is already on the PATH.
- The input file `ERR1755082_1.fastq.gz` is stored in the shared resources, next to the container file.
- For tidiness, manually create a subdirectory in your project directory,
  and pass the path to this directory to the `fastqc` command.
- The full command should look like `fastqc -o /path/to/output /path/to/input`.
- Remember to bind input and output directories to the container.

# Creating Containers

## Creating containers

Step 1: Write a definition file.

A definition file generally refers to an existing image to use as a basis for the new image.

A definition file is organised into sections^[<https://apptainer.org/docs/user/main/definition_files.html#sections>].

### Key sections

`%help` : message displayed by the run-help command.

`%post` : commands to modify the container (e.g., download files, install software, create directories).

`%environment` : define environment variables.

## Example Definition File

```bash
bootstrap: localimage
From: /project/shared/resources/containers/miniforge.sif

%help
 Miniforge 24.3.0-0 (Mamba 1.5.8 + Conda 24.1.2) + FastQC

%environment
 export PATH=/usr/local/mamba/bin:$PATH

%post
 mamba install -q -y -c bioconda fastqc
```

## Header and Bootstrap Agent

The bootstrap agent indicates where the base image should be obtained from^[<https://apptainer.org/docs/user/main/definition_files.html#header>].

In this lesson we use the following agents:

- `docker` , for images hosted online on Docker Hub.

```
bootstrap: docker
From: ubuntu:22.04
```

- `localimage` , for images saved on the teaching server.

```
bootstrap: localimage
From: /project/shared/resources/containers/miniforge.sif
```

## Building a Container

```bash
apptainer build <filename>.sif <filename>.def
```

### Remember

- `*.sif` is used for image files.
- `*.def` is used for definition files.

## Sharing a Container

Image files can be copied, but will only work on systems that have the same CPU architecture.

`r fa("triangle-exclamation")` Faster, with a major caveat.

Definition files can be used to build more copies of the same image on other systems.

`r fa("thumbs-up")` Slower, but CPU compatibility is guaranteed.

::: {.callout-note}
If the definition requires a local base image, you may have to build that one first (and so on).
:::

## Exercise

Using the prepared container definition file:

```
/project/shared/resources/containers/.../samtools.def
```

Build an image file called `samtools.sif` in your project directory.

Test the image, running the command `samtools`.

## Exercise

Choose a program that you already know how to use.

Write a definition file and create an image that includes that program.

Run a test command to prove that the program is successfully installed in the container.

## RStudio Server in a Container

On OBDS and JADE, the standard RStudio server restricts memory allowance in interactive sessions for fair usage between users.

A container image that contains RStudio server can be run as a job on a compute node of JADE

The process is not straightforward but documented at <https://lumin.imm.ox.ac.uk/R-cbrg/#rstudio-container>.

In this lesson, we follow those instructions, adapted to the OBDS server.

## Running an RStudio Server Container on the OBDS Server

```{r}
#| fig-cap: "Illustration of RStudio Server containers on the OBDS server (Source: Kevin Rue)."
knitr::include_graphics("img/containers-draft-02-slide-29.svg")
```

## What the RStudio Server Container Does

The container runs an instance of RStudio server on a port specific to each user.

### How?

- User IDs are numbers.
- The container uses the ID of the user running the container to calculate a unique port number within an acceptable range of values.

### What then?

Step 1. Run an instance of the container as a Slurm job.

Step 2. While the container is running, connect to the port that runs your own instance of the RStudio Server.

::: {.callout-note}
Step 2 is not straightforward. We give you a semi-automated script for that.
:::

## Exercise

### Running the RStudio Server Container

For this first part of the process, you must run the following commands **on the OBDS server**.

Submit a Slurm job that runs the container.

```bash
sbatch /project/shared/resources/containers/.../rstudio-container.sh
```

Check that the job is running.

```bash
squeue –me
```

Display the contents of the job output file (substitute `JOBID` by the job identifier reported by the previous command).

```bash
cat slurm-JOBID.out
```

Make a note of the password displayed by the last command. You will need it in the second part of the process.

## Exercise

### Connecting to your RStudio Server Container

This first part of the process takes place **on your own computer** (not on your OBDS account).

Make a copy of the appropriate script below .

- Windows: `connect-to-wn-rstudio.bat`
- Linux / macOS: `connect-to-wn-rstudio.sh`

Run the script.

- Windows: double click on the file.
- Linux / macOS: In a terminal, type `bash connect-to-rstudio-server-obds.sh`.

Follow the instructions displayed by the script.

- Type your username when prompted (first time only^[The username will be cached in a file in your home directory for subsequent uses.])
- Open a web browser tab to <http://localhost:8888>
- Log in using you SSO (username) and the random password copied earlier.

## Using a Custom Package Library with the RStudio Server Container

In the `apptainer run` command, bind a directory using the `-B` option.

```bash
–B /project/username/my_library
```

Submit a Slurm job that runs the container.

```bash
sbatch /project/shared/resources/containers/.../rstudio-container.sh
```

In the Rstudio Server session, add the same directory to your R library path.

```r
.libPaths("/project/username/my_library/")
```

Install your favourite packages.

```r
install.packages("tidyverse")
```

### Key points

- The packages will be installed in the bound directory (first in the library path).
- The directory (and packages) will remain after the container is terminated and can be re-used by other containers.

# Summary

## Summary

Containers provide a fixed environment to facilitate reproducible work.

Containers can be shared, locally or online.

New containers can be created, from minimal operating systems or from other containers.

You are encouraged to create and share your own containers:

- You can install any version of any software in your own containers.
- You can ask more disk quota if you run out of storage for containers.

## Further Reading

- [WIMM CCB documentation](https://lumin.imm.ox.ac.uk/containers/) (Requires SSO)
- [Apptainer documentation](https://apptainer.org/documentation/)
- [BMRC documentation](https://www.medsci.ox.ac.uk/for-staff/resources/bmrc/scientific-software-directory)

## References

```{r}
#| results: asis
PrintBibliography(bib)
```
