---
title: "Solution: Differential expression analysis for RNA-seq data"
author: "Kevin Rue-Albrecht"
date: "18/08/2023"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(DESeq2)
```

## Exercise

### Import gene data and metadata

- Load the `tidyverse` package,
  and use the function `read_tsv()`
  to import count data from the file `allsamples_counts.tsv.gz`
  into a tibble called `featurecounts_table`.
  Display a preview of `featurecounts_table` using `glimpse()`.

```{r}
library(tidyverse)
featurecounts_table <- read_tsv("data/allsamples_counts.tsv.gz", comment = "#")
glimpse(featurecounts_table)
```

- Extract gene metadata from the tibble `featurecounts_table` into a new tibble called `gene_info`.
  Display a preview of `gene_info` using `glimpse()`.

```{r}
gene_info <- featurecounts_table %>%
    column_to_rownames("Geneid") %>%
    select(Chr, Start, End, Strand, Length)
glimpse(gene_info)
```
- Similarly, extract the read counts per sample from `featurecounts_table`
  into a numeric matrix called `counts_table`.
  Display the first few rows of `counts_table` using `head()`.

```{r}
counts_table <- featurecounts_table %>%
    column_to_rownames("Geneid") %>%
    select(-Chr, -Start, -End, -Strand, -Length) %>%
    as.matrix()
head(counts_table)
```

- Display the dimensions of the matrix `counts_table`.

```{r}
dim(counts_table)
```

- What does the function `storage.mode()` tell you about `counts_table`?

```{r}
storage.mode(counts_table)
```

## Exercise

### Import sample metadata

- Import sample metadata from the file `PRJEB18572_sample_info.tsv`
  into a tibble called `sample_info`
  using the tidyverse function `read_tsv()`.
  Display the object `sample_info`.

```{r}
sample_info <- read_tsv("data/PRJEB18572_sample_info.tsv")
sample_info
```

- What is the class of the column called `cell_type`?

```{r}
class(sample_info$cell_type)
```

- Convert the column `cell_type` to a factor.

```{r}
sample_info$cell_type <- as.factor(sample_info$cell_type)
```

- What is the default order of the levels of that factor?

```{r}
levels(sample_info$cell_type)
```

- One more time, convert the column `cell_type` to a factor,
  this time setting the levels of that factor to be `CD8` first, then `CD4`.
  Demonstrate that it worked.

```{r}
sample_info$cell_type <- factor(sample_info$cell_type, levels = c("CD8", "CD4"))
levels(sample_info$cell_type)
```

**How does the order of the levels impact the differential expression analysis?**

- What other columns might we want to include in the experimental design of our differential expression analysis?
  Convert those to factors too.
  Display the full tibble `sample_info` again.

```{r}
sample_info$genotype <- factor(sample_info$genotype, c("Egr2_Kin", "Egr2_Egr3_KO"))
sample_info$replicate <- factor(sample_info$replicate, c(1, 2, 3))
sample_info
```

## Exercise

### Sanity check and preprocess data

- Check whether sample names in the count matrix (column names) and sample meta (column `sample_id`) match.

```{r}
colnames(counts_table) == sample_info$sample_id
```

- If not, display the two sets of sample names.
  (Hint: you display them individually, or as two columns in a single tibble, for easier side-by-side comparison).

```{r}
tibble(
    counts_table = colnames(counts_table),
    sample_info = sample_info$sample_id
)
```

**What makes the two sets of sample names different from each other?**

- Remove `.bam` from the column names of the matrix to match the `sample_id` column of the sample metadata.

```{r}
colnames(counts_table) <- colnames(counts_table) %>%
    str_replace(".bam","")
```

- Check (again) whether sample names in the count matrix (column names) and sample meta (column `sample_id`) match.

```{r}
# get a vector of pairwise comparisons
colnames(counts_table) == sample_info$sample_id
# get a single overall answer whether the two whole vectors are identical
identical(
    colnames(counts_table),
    sample_info$sample_id
)
```

## Exercise

### Construct a DESeqDataSet object

- Load the package `DESeq2`
  and use the function `DESeqDataSetFromMatrix()`
  to construct a `DESeqDataSet` called `dds`
  using the count matrix `counts_table`
  and the tibble `sample_info`.
  Define an experimental design that includes only `cell_type` for now.

```{r}
library(DESeq2)
dds <- DESeqDataSetFromMatrix(
    countData = counts_table,
    colData = sample_info,
    design = ~ cell_type
)
```

- Rewrite the code above, adding a line using the function `storage.mode()` to avoid the message "converting counts to integer mode", printed by the function `DESeqDataSetFromMatrix()`.

```{r}
storage.mode(counts_table) <- "integer"
dds <- DESeqDataSetFromMatrix(
    countData = counts_table,
    colData = sample_info,
    design = ~ cell_type
)
```

- Display the `dds` object.

```{r}
dds
```

## Exercise

### Explore a DESeqDataSet object

- Use the function `class()` to demonstrate that the object `dds` is a `DESeqDataSet`.

```{r}
class(dds)
```

- Use the function `is()` to demonstrate that `dds` is also a `SummarizedExperiment`.

```{r}
is(dds, "SummarizedExperiment")
```

- Given that `dds` is a `SummarizedExperiment`, what do the following methods tell you about `dds`?
  + `assayNames()`
  + `assays()`
  + `assay()`
  + `colData()`
  + `rowData()`
  + `metadata()`

```{r}
assayNames(dds)
assays(dds)
head(assay(dds, "counts"))
colData(dds)
rowData(dds)
metadata(dds)
```

- Furthermore, as a `DESeqDataSet`, what do the following methods tell you about `dds`?
  + `counts()`
  + `design()`
  + `sizeFactors()`
  + `dispersions()`

```{r}
head(counts(dds))
design(dds)
sizeFactors(dds)
dispersions(dds)
```

- As a `SummarizedExperiment`, the `dds` object can also be indexed using `[`.
  Extract the rows 1 to 5 and columns 1 to 4.
  Display the result without assigning it to any object.

```{r}
dds[1:5, 1:4]
```

## Exercise

### Filter out lowly genes expressed

- Use the functions `counts()` and `rowSums()`
  to count the number of samples in which each gene is expressed
  (i.e., strictly more than zero read counts).
  Use that information to extract genes expressed in at least 4 samples
  into a new object called `dds_filtered`.
  Display the object `dds_filtered`.

```{r}
dds_filtered <- dds[rowSums(counts(dds) > 0) >= 4, ]
dds_filtered
```

**How many genes remain after filtering?**

### Bonus point(s)

Explore different cut-offs and filtering strategies, e.g.

- Change the minimum read count cut-off from 0 to higher values.
- Change the number of samples in which genes should be detected above the read count cut-off.
- Keep only genes detected above the read count cut-off in all the samples of either cell type.

```{r}
# apply to each row (MARGIN=1) of the dds counts matrix, an anonymous function that:
# - uses 'tapply' to group counts by 'cell_type'
# - for each cell type, asks the question whether all counts are greater than 0
# - looks at the result of 'tapply' and asks the question whether the answer for any cell type is TRUE
# The answer for each gene is recorded in the logical vector 'keep'
# which can be used to index the DESeqDataSet object 'dds'
keep <- apply(X = counts(dds), MARGIN = 1, FUN = function(x) {
    any(tapply(counts(dds)[1, ], dds$cell_type, function(x) { all(x > 0) }))
})
# tidyverse alternative
keep <- counts(dds) %>%
    as.data.frame() %>% 
    rownames_to_column("gene_id") %>% 
    as_tibble() %>%
    pivot_longer(-gene_id) %>% 
    left_join(
        colData(dds) %>% as_tibble(),
        by = c("name" = "sample_id")) %>% 
    group_by(gene_id, cell_type) %>% 
    summarise(all_samples = all(value > 0)) %>% 
    summarise(all_samples_any_celltype = any(all_samples)) %>% 
    filter(all_samples_any_celltype) %>% 
    pull(gene_id)
dds[keep, ]
```
