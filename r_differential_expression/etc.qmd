## Differential expression {.smaller}

:::: {.columns}

::: {.column width="50%"}
```{r}
#| fig-align: center
knitr::include_graphics("img/counts_coldata.png")
```

```{r}
deseq2_res
```
:::

::: {.column width="50%"}
```{r}
#| fig-align: center
x <- plotMA(deseq2_res, returnData = TRUE)
ggplot() +
  geom_point(
    aes(mean, lfc, colour = isDE),
    x %>% filter(!is.na(lfc)),
    size = 0.2) +
  scale_x_log10() +
  scale_colour_manual(values = c("FALSE" = "grey", "TRUE" = "blue")) +
  labs(
    x = "Mean of normalised counts",
    y = "Log fold-change",
    title = "MA plot"
  ) +
  theme_minimal() +
  theme(
    title = element_text(size = 20),
    text = element_text(size = 14)
  )
```

```{r}
#| fig-align: center
x <- as_tibble(deseq2_res)
ggplot() +
  geom_point(
    aes(log2FoldChange, -log10(pvalue), colour = isDE),
    x %>%
      filter(!is.na(log2FoldChange) & !is.na(pvalue)) %>% 
      mutate(isDE = padj < 0.05),
    size = 0.2) +
  scale_colour_manual(values = c("FALSE" = "grey", "TRUE" = "blue")) +
  labs(
    x = "Log fold-change",
    y = "-log10(P)",
    title = "Volcano plot"
  ) +
  theme_minimal() +
  theme(
    title = element_text(size = 20),
    text = element_text(size = 14)
  )
```
:::

::::

## Goals of differential expression analysis

::: {style="text-align: center;"}
**Quantify differences between groups, taking into account variability within groups.**
:::

### Examples hypotheses

- Which genes are significantly *up- or down-regulated* in *condition* A relative to condition B?
- Which genes are significantly affected by the *interaction* of *covariates* A and B, taking into account the *independent* effect of those covariates?
- Which genes show significant variation over a *time course*?

### Input data

Most methods require raw count data.

- Range of methods including
  `r BiocStyle::Biocpkg("DESeq2")`
  and `r BiocStyle::Biocpkg("edgeR")`.
- Suitable for various assays including RNA-seq, ChIP-seq, and ATAC-seq.
- Read count associated with features of interest (e.g., gene, transcript, exon).

### Outputs

- A table of statistics, often accompanied by plots for quality control and further analyses.

## Differential expression within an RNA-seq workflow

```{r}
#| fig-align: center
knitr::include_graphics("img/overview-rnaseq-workflow.png")
```

## Packages for differential expression analysis

### RNA-seq data

#### Gene / transcripts

- `r BiocStyle::Biocpkg("DESeq2")` `r Citep(bib, "deseq2_package")`.
- `r BiocStyle::Biocpkg("edgeR")` `r Citep(bib, "edger_package")`.

#### Exons

- `r BiocStyle::Biocpkg("DEXSeq")` `r Citep(bib, "dexseq_package")`.
  Note: uses `r BiocStyle::Biocpkg("DESeq2")` internally

#### Salmon / Kallisto

- `r BiocStyle::Githubpkg("pachterlab/sleuth")` `r Citep(bib, "sleuth_package")`.

### ChIP-seq data

- `r BiocStyle::Biocpkg("DiffBind")` `r Citep(bib, "diffbind_package")`.
  Note: uses either `r BiocStyle::Biocpkg("edgeR")` or `r BiocStyle::Biocpkg("DESeq2")` internally.

## DESeq2

### Publications

- "Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2" `r Citep(bib, "deseq2_2014")`

### Package vignette

- [Analyzing RNA-seq data with DESeq2](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)
- In the <i class="fab fa-r-project"></i> console:

```{r}
#| eval: false
#| echo: true
vignette("DESeq2")
```

### Bioconductor support site

- <https://support.bioconductor.org/>

### Other resources

- [Gene-level differential expression analysis
](https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/01c_RNAseq_count_distribution.html) -- Harvard Chan Bioinformatics Core
- [StatQuest: DESeq2 part 1: Library Normalization](https://statquest.org/statquest-deseq2-part-1-library-normalization/)

## Exploratory analysis

```{r}
#| fig-align: center
knitr::include_graphics("img/de-exploratory-analysis.png")
```

:::: {.columns}

::: {.column width="50%"}
#### Part 1

- Get familiar with the data.
- Expect the unexpected.
:::

::: {.column width="50%"}
#### Part 2

- Model the data.
- Inspect the results.
- Downstream analyses.
:::

::::

## Input data

In <i class="fab fa-r-project"></i>,
a differential expression analysis needs three key inputs:

- A matrix of read counts for each feature in each sample.

```{r}
n_genes <- 3
n_samples <- 4
matrix(
  data = rbinom(n_genes * n_samples, 10, 0.1),
  nrow = n_genes,
  ncol = n_samples,
  dimnames = list(
    paste0("gene_", 1:n_genes),
    paste0("S", 1:n_samples)
  )
)
```

- A table of metadata for each sample.

```{r}
data.frame(
  sample_id = paste0("S", 1:n_samples),
  condition = factor(sample(c("A", "B"), size = n_samples, replace = TRUE)),
  age = sample(30:60, size = n_samples, replace = TRUE)
)
```


- A formula that describes the experimental design.

```{r}
#| echo: true
#| eval: false
~ age + condition
```

## The Bioconductor SummarizedExperiment

`r BiocStyle::Biocpkg("SummarizedExperiment")` provides a base class that is re-used throughout Bioconductor packages.

```{r}
#| fig-align: center
knitr::include_graphics("img/summarizedexperiment.jpeg")
```

## The DESeq2 DESeqDataSet

```{r}
oo <- options()
options(width = 60)
```

`r BiocStyle::Biocpkg("DESeq2")` defines the class `DESeqDataSet` that extends the class `RangedSummarizedExperiment`.

```{r}
dds_se <- as(dds, "RangedSummarizedExperiment")
```

<br/>

:::: {.columns}

::: {.column width="50%"}
### `r as.character(class(dds_se))`

```{r}
slotNames(dds_se)
```
:::

::: {.column width="50%"}
### `r as.character(class(dds))`

```{r}
slotNames(dds)
```
:::

::::

<br/>

::: {style="text-align: center;"}
**What slots does the class `DESeqDataSet` add to the base case `RangedSummarizedExperiment`?**
:::

## Additional slots

`design`

- Dedicated to the storage of the formula that describes the experimental design.

`dispersionFunction`

- Dedicated to the storage of the function that models dispersion in the data.

```{r}
options(oo)
```

## Exercise

### Import gene data and metadata

- Load the `tidyverse` package,
  and use the function `read_tsv()`
  to import count data from the file `allsamples_counts.tsv.gz`
  into a tibble called `featurecounts_table`.
  Display a preview of `featurecounts_table` using `glimpse()`.
- Extract gene metadata from the tibble `featurecounts_table` into a new tibble called `gene_info`.
  Display a preview of `gene_info` using `glimpse()`.
- Similarly, extract the read counts per sample from `featurecounts_table`
  into a numeric matrix called `counts_table`.
  Display the first few rows of `counts_table` using `head()`.
- Display the dimensions of the matrix `counts_table`.
- What does the function `storage.mode()` tell you about `counts_table`?

## Exercise

### Import sample metadata

- Import sample metadata from the file `PRJEB18572_sample_info.tsv`
  into a tibble called `sample_info`
  using the tidyverse function `read_tsv()`.
  Display the object `sample_info`.
- What is the class of the column called `cell_type`?
- Convert the column `cell_type` to a factor.
- What is the default order of the levels of that factor?
- One more time, convert the column `cell_type` to a factor,
  this time setting the levels of that factor to be `CD8` first, then `CD4`.
  Demonstrate that it worked.

::: {style="text-align: center;"}
**How does the order of the levels impact the differential expression analysis?**
:::

- What other columns might we want to include in the experimental design of our differential expression analysis?
  Convert those to factors too.
  Display the full tibble `sample_info` again.

## Exercise

### Sanity check and preprocess data

- Check whether sample names in the count matrix (column names) and sample meta (column `sample_id`) match.
- If not, display the two sets of sample names.
  (Hint: you display them individually, or as two columns in a single tibble, for easier side-by-side comparison).

::: {style="text-align: center;"}
**What makes the two sets of sample names different from each other?**
:::

- Remove `.bam` from the column names of the matrix to match the `sample_id` column of the sample metadata.
- Check (again) whether sample names in the count matrix (column names) and sample meta (column `sample_id`) match.

## Exercise

### Construct a DESeqDataSet object

- Load the package `DESeq2`
  and use the function `DESeqDataSetFromMatrix()`
  to construct a `DESeqDataSet` called `dds`
  using the count matrix `counts_table`
  and the tibble `sample_info`.
  Define an experimental design that includes only `cell_type` for now.

::: {style="text-align: center;"}
**The function `DESeqDataSetFromMatrix()` is expected to printed the message "converting counts to integer mode". Why?**
:::

- Rewrite the code above, adding a line using the function `storage.mode()` to avoid the message.
- Display the `dds` object.

## Exercise

### Explore a DESeqDataSet object

- Use the function `class()` to demonstrate that the object `dds` is a `DESeqDataSet`.
- Use the function `is()` to demonstrate that `dds` is also a `SummarizedExperiment`.
- Given that `dds` is a `SummarizedExperiment`, what do the following methods tell you about `dds`?

:::: {.columns}

::: {.column width="33%"}
`assayNames()`

`assays()`
:::

::: {.column width="33%"}
`assay()`

`colData()`
:::

::: {.column width="33%"}
`rowData()`

`metadata()`
:::

::::

- Furthermore, as a `DESeqDataSet`, what do the following methods tell you about `dds`?

:::: {.columns}

::: {.column width="50%"}
`counts()`

`design()`
:::

::: {.column width="50%"}
`sizeFactors()`

`dispersions()`
:::

::::

- As a `SummarizedExperiment`, the `dds` object can also be indexed using `[`.
  Extract the rows 1 to 5 and columns 1 to 4.
  Display the result without assigning it to any object.

## Exercise

### Filter out lowly genes expressed

- Use the functions `counts()` and `rowSums()`
  to count the number of samples in which each gene is expressed
  (i.e., strictly more than zero read counts).
  Use that information to extract genes expressed in at least 4 samples
  into a new object called `dds_filtered`.
  Display the object `dds_filtered`.

::: {style="text-align: center;"}
**How many genes remain after filtering?**
:::

### Bonus point(s)

Explore different cut-offs and filtering strategies, e.g.

- Change the minimum read count cut-off from 0 to higher values.
- Change the number of samples in which genes should be detected above the read count cut-off.
- Keep only genes detected above the read count cut-off in all the samples of either cell type.

## Exercise

### Preprocessing for exploratory analysis and quality control

- Use the function `rlog()` to transform the counts data using the 'regularised log' transformation.
  Leave the argument `blind=` set to its default value `TRUE`.
  Assign the result to a new object named `dds_rlog`.
  Display the object `dds_rlog`.
  What is the class of the object?

### Bonus point(s)

- Use the function `vst()` to transform the counts data using the 'variance stabilizing' transformation.
  Leave the argument `blind=` set to its default value `TRUE`.
  Assign the result to a new object named `dds_vst`.
  Display the object `dds_vst`.
  What is the class of the object?

::: {style="text-align: center;"}
**Can you spot differences between the rlog() and vst() outputs?**
:::

## Exercise

### Exploratory analysis and quality control

Using either of the objects `dds_rlog` or `dds_vst` produced earlier.

- Use the function `plotPCA()`.
  Set the argument `intgroup` to `"cell_type"`.

::: {style="text-align: center;"}
**How many samples do you count?**
:::

- Use the functions `assay()` and `cor()`
  to compute a correlation matrix between samples using the "spearman" method.
  Load the `pheatmap` package and use the function `pheatmap()`
  to plot a heat map of correlations between samples.

::: {style="text-align: center;"}
**What can you tell from the scale of correlation values?**
:::

- Use the functions `assay()`, `t()` and `dist()`
  to compute the Euclidean distance matrix between samples.
  Use the function `pheatmap()`
  to plot a heat map of distances between samples.
- Confirm that the suspicious samples are duplicate of each other.
- Index the `dds_filtered` object to extract the unique samples
  into a new object called `dds_filtered_unique`.
  Display the sample metadata of the new object
  (compare with objects prior to indexing).

## Exercise

### Perform differential expression analysis

- Display the design formula stored in the object `dds_filtered_unique`
  and check it against the sample metadata stored in the same object
  to confirm that it is still valid
  with respect to the differential expression analysis that we wish to perform.
- Use the function `DESeq()` to perform the differential expression analysis
  on the object `dds_filtered_unique`.
  Re-assign the output to the same name.
  Display the object.

::: {style="text-align: center;"}
**What differences can you see with this object printed earlier in the notebook?**
:::

- Use the function `results()` to extract the differential expression results
  from the object `dds_filtered_unique`.
  Assign the result to an object called `dds_results`.

::: {style="text-align: center;"}
**How do you know that extracted the results for the desired contrast?**
:::

- What does the function `summary()` tell you about the object `dds_results`?

## References

```{r}
#| results: asis
PrintBibliography(bib)
```
